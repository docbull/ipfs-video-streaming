export function fromFixture(fixture, invalidTestCase = {}) {
    const { suggestions, ...rest } = invalidTestCase;
    return {
        ...rest,
        ...parseFixture(fixture, suggestions),
    };
}
function getSuggestions(suggestions, indices) {
    if (!suggestions || indices === "") {
        return {};
    }
    if (indices === undefined) {
        return { suggestions };
    }
    return {
        suggestions: indices
            .split(/\s+/)
            .map((index) => suggestions[Number.parseInt(index, 10)]),
    };
}
function parseFixture(fixture, suggestions) {
    const errorRegExp = /^(?<indent>\s*)(?<error>~+)\s*\[(?<id>\w+)\s*(?<data>.*?)(?:\s*suggest\s*(?<indices>[\d\s]*))?\]\s*$/;
    const lines = [];
    const errors = [];
    fixture.split("\n").forEach((line) => {
        var _a;
        const match = line.match(errorRegExp);
        if (match === null || match === void 0 ? void 0 : match.groups) {
            const column = match.groups.indent.length + 1;
            const endColumn = column + match.groups.error.length;
            const { length } = lines;
            errors.push({
                column,
                data: JSON.parse(match.groups.data || "{}"),
                endColumn,
                endLine: length,
                line: length,
                messageId: match.groups.id,
                ...getSuggestions(suggestions, (_a = match.groups.indices) === null || _a === void 0 ? void 0 : _a.trim()),
            });
        }
        else {
            lines.push(line);
        }
    });
    return {
        code: lines.join("\n"),
        errors,
    };
}
//# sourceMappingURL=from-fixture.js.map