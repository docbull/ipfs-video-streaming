"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getJsDocComment = exports.getSignatureComment = exports.getComment = void 0;
const ts = require("typescript");
const models_1 = require("../../models");
const utils_1 = require("../../utils");
const blockLexer_1 = require("./blockLexer");
const discovery_1 = require("./discovery");
const parser_1 = require("./parser");
const commentCache = new WeakMap();
function getCommentWithCache(discovered, config, logger) {
    if (!discovered)
        return;
    const [file, range] = discovered;
    const cache = commentCache.get(file) || new Map();
    if (cache === null || cache === void 0 ? void 0 : cache.has(range.pos)) {
        return cache.get(range.pos).clone();
    }
    const line = ts.getLineAndCharacterOfPosition(file, range.pos).line + 1;
    logger.verbose(`Parsing comment at ${file.fileName}:${line}`);
    const warning = (warning) => logger.warn(`${warning} in comment at ${file.fileName}:${line}.`);
    let comment;
    switch (range.kind) {
        case ts.SyntaxKind.MultiLineCommentTrivia:
            comment = (0, parser_1.parseComment)((0, blockLexer_1.lexBlockComment)(file.text, range.pos, range.end), config, warning);
            break;
        case ts.SyntaxKind.SingleLineCommentTrivia:
            throw "GERRIT FIX ME"; // GERRIT
        default:
            (0, utils_1.assertNever)(range.kind);
    }
    cache.set(range.pos, comment);
    commentCache.set(file, cache);
    return comment.clone();
}
function getComment(symbol, kind, config, logger) {
    var _a;
    const comment = getCommentWithCache((0, discovery_1.discoverComment)(symbol, kind), config, logger);
    if (((_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.some(ts.isSourceFile)) && comment) {
        // Module comment, make sure it is tagged with @packageDocumentation or @module.
        // If it isn't then the comment applies to the first statement in the file, so throw it away.
        if (!comment.hasModifier("@packageDocumentation") &&
            !comment.getTag("@module")) {
            return;
        }
    }
    return comment;
}
exports.getComment = getComment;
function getSignatureComment(declaration, config, logger) {
    return getCommentWithCache((0, discovery_1.discoverSignatureComment)(declaration), config, logger);
}
exports.getSignatureComment = getSignatureComment;
function getJsDocComment(declaration, config, logger) {
    var _a, _b;
    const file = declaration.getSourceFile();
    // First, get the whole comment. We know we'll need all of it.
    let parent = declaration.parent;
    while (!ts.isJSDoc(parent)) {
        parent = parent.parent;
    }
    // Then parse it.
    const comment = getCommentWithCache([
        file,
        {
            kind: ts.SyntaxKind.MultiLineCommentTrivia,
            pos: parent.pos,
            end: parent.end,
        },
    ], config, logger);
    // And pull out the tag we actually care about.
    if (ts.isJSDocEnumTag(declaration)) {
        return new models_1.Comment((_a = comment.getTag("@enum")) === null || _a === void 0 ? void 0 : _a.content);
    }
    if (ts.isJSDocTemplateTag(declaration) &&
        declaration.comment &&
        declaration.typeParameters.length > 1) {
        // We could just put the same comment on everything, but due to how comment parsing works,
        // we'd have to search for any @template with a name starting with the first type parameter's name
        // which feels horribly hacky.
        logger.warn(`TypeDoc does not support multiple type parameters defined in a single @template tag with a comment.`, declaration);
        return;
    }
    let name;
    if (ts.isJSDocTemplateTag(declaration)) {
        // This isn't really ideal.
        name = declaration.typeParameters[0].name.text;
    }
    else {
        name = (_b = declaration.name) === null || _b === void 0 ? void 0 : _b.getText();
    }
    if (!name) {
        return;
    }
    const tag = comment.getIdentifiedTag(name, `@${declaration.tagName.text}`);
    if (!tag) {
        logger.error(`Failed to find JSDoc tag for ${name} after parsing comment, please file a bug report.`, declaration);
    }
    else {
        return new models_1.Comment(tag.content);
    }
}
exports.getJsDocComment = getJsDocComment;
//# sourceMappingURL=index.js.map