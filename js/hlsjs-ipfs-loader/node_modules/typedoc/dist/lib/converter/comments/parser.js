"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseComment = void 0;
const assert_1 = require("assert");
const models_1 = require("../../models");
const utils_1 = require("../../utils");
const blockLexer_1 = require("./blockLexer");
function makeLookaheadGenerator(gen) {
    let nextItem = gen.next();
    return {
        done() {
            return !!nextItem.done;
        },
        peek() {
            (0, assert_1.ok)(!nextItem.done);
            return nextItem.value;
        },
        take() {
            const thisItem = nextItem;
            (0, assert_1.ok)(!thisItem.done);
            nextItem = gen.next();
            return thisItem.value;
        },
    };
}
function parseComment(tokens, config, warning) {
    const lexer = makeLookaheadGenerator(tokens);
    const comment = new models_1.Comment();
    comment.summary = blockContent(comment, lexer, config, warning);
    while (!lexer.done()) {
        comment.blockTags.push(blockTag(comment, lexer, config, warning));
    }
    postProcessComment(comment, warning);
    return comment;
}
exports.parseComment = parseComment;
const HAS_USER_IDENTIFIER = [
    "@callback",
    "@param",
    "@prop",
    "@property",
    "@template",
    "@typedef",
    "@typeParam",
    // GERRIT Kind of hacky to have this one here.
    "@inheritDoc",
];
/**
 * Loop over comment, produce lint warnings, and set tag names for tags
 * which have them.
 */
function postProcessComment(comment, warning) {
    for (const tag of comment.blockTags) {
        if (HAS_USER_IDENTIFIER.includes(tag.tag) && tag.content.length) {
            const first = tag.content[0];
            if (first.kind === "text") {
                let end = first.text.search(/\s/);
                if (end === -1)
                    end = first.text.length;
                tag.name = first.text.substring(0, end);
                if (tag.name.startsWith("[") && tag.name.endsWith("]")) {
                    tag.name = tag.name.slice(1, -1);
                }
                first.text = first.text.substring(end);
                const endOfTrivia = first.text.search(/[^\-\s]/);
                if (endOfTrivia !== -1) {
                    first.text = first.text.substring(endOfTrivia);
                }
                else {
                    // Remove this token, no real text in it.
                    tag.content.shift();
                }
            }
        }
    }
    const remarks = comment.blockTags.filter((tag) => tag.tag === "@remarks");
    if (remarks.length > 1) {
        warning("At most one @remarks tag is expected in a comment, ignoring all but the first");
        (0, utils_1.removeIf)(comment.blockTags, (tag) => remarks.indexOf(tag) > 0);
    }
}
const aliasedTags = new Map([["@return", "@returns"]]);
function blockTag(comment, lexer, config, warning) {
    const blockTag = lexer.take();
    (0, assert_1.ok)(blockTag.kind === blockLexer_1.TokenSyntaxKind.Tag); // blockContent is broken if this fails.
    const tagName = aliasedTags.get(blockTag.text) || blockTag.text;
    return new models_1.CommentTag(tagName, blockContent(comment, lexer, config, warning));
}
function blockContent(comment, lexer, config, warning) {
    const content = [];
    let atNewLine = true;
    loop: while (!lexer.done()) {
        const next = lexer.peek();
        let consume = true;
        switch (next.kind) {
            case blockLexer_1.TokenSyntaxKind.NewLine:
            case blockLexer_1.TokenSyntaxKind.Text:
                content.push({ kind: "text", text: next.text });
                break;
            case blockLexer_1.TokenSyntaxKind.Code:
                content.push({ kind: "code", text: next.text });
                break;
            case blockLexer_1.TokenSyntaxKind.Tag:
                if (config.modifierTags.has(next.text)) {
                    comment.modifierTags.add(next.text);
                    break;
                }
                else if (!atNewLine && !config.blockTags.has(next.text)) {
                    // Treat unknown tag as a modifier, but warn about it.
                    comment.modifierTags.add(next.text);
                    warning(`Treating unrecognized tag "${next.text}" as a modifier tag`);
                    break;
                }
                else {
                    // Block tag or unknown tag, handled by our caller.
                    break loop;
                }
            case blockLexer_1.TokenSyntaxKind.TypeAnnotation:
                // We always ignore these. In TS files they are redundant, in JS files
                // they are required.
                break;
            case blockLexer_1.TokenSyntaxKind.CloseBrace:
                // Unmatched closing brace, generate a warning, and treat it as text.
                warning(`Unmatched closing brace in comment`);
                content.push({ kind: "text", text: next.text });
                break;
            case blockLexer_1.TokenSyntaxKind.OpenBrace:
                inlineTag(lexer, content, config, warning);
                consume = false;
                break;
            default:
                (0, utils_1.assertNever)(next.kind);
        }
        if (consume && lexer.take().kind === blockLexer_1.TokenSyntaxKind.NewLine) {
            atNewLine = true;
        }
    }
    // Collapse adjacent text parts
    for (let i = 0; i < content.length - 1 /* inside loop */;) {
        if (content[i].kind === "text" && content[i + 1].kind === "text") {
            content[i].text += content[i + 1].text;
            content.splice(i + 1, 1);
        }
        else {
            i++;
        }
    }
    // Now get rid of extra whitespace, and any empty parts
    for (let i = 0; i < content.length /* inside loop */;) {
        if (i === 0 || content[i].kind === "inline-tag") {
            content[i].text = content[i].text.trimStart();
        }
        if (i === content.length - 1 || content[i].kind === "inline-tag") {
            content[i].text = content[i].text.trimEnd();
        }
        if (!content[i].text && content[i].kind === "text") {
            content.splice(i, 1);
        }
        else {
            i++;
        }
    }
    return content;
}
function inlineTag(lexer, block, config, warning) {
    const openBrace = lexer.take();
    // Now skip whitespace to grab the tag name.
    // If the first non-whitespace text after the brace isn't a tag,
    // then produce a warning and treat what we've consumed as plain text.
    if (lexer.done() ||
        ![blockLexer_1.TokenSyntaxKind.Text, blockLexer_1.TokenSyntaxKind.Tag].includes(lexer.peek().kind)) {
        warning("Encountered an unescaped open brace without an inline tag");
        block.push({ kind: "text", text: openBrace.text });
        return;
    }
    let tagName = lexer.take();
    if (lexer.done() ||
        (tagName.kind === blockLexer_1.TokenSyntaxKind.Text &&
            (!/^\s+$/.test(tagName.text) ||
                lexer.peek().kind != blockLexer_1.TokenSyntaxKind.Tag))) {
        warning("Encountered an unescaped open brace without an inline tag");
        block.push({ kind: "text", text: openBrace.text + tagName.text });
        return;
    }
    if (tagName.kind !== blockLexer_1.TokenSyntaxKind.Tag) {
        tagName = lexer.take();
    }
    if (!config.inlineTags.has(tagName.text)) {
        warning(`Encountered an unknown inline tag "${tagName.text}"`);
    }
    const content = [];
    // At this point, we know we have an inline tag. Treat everything following as plain text,
    // until we get to the closing brace.
    while (!lexer.done() && lexer.peek().kind !== blockLexer_1.TokenSyntaxKind.CloseBrace) {
        const token = lexer.take();
        if (token.kind === blockLexer_1.TokenSyntaxKind.OpenBrace) {
            warning("Encountered an open brace within an inline tag, this is likely a mistake");
        }
        content.push(token.kind === blockLexer_1.TokenSyntaxKind.NewLine ? " " : token.text);
    }
    if (lexer.done()) {
        warning("Inline tag is not closed");
    }
    else {
        lexer.take(); // Close brace
    }
    block.push({
        kind: "inline-tag",
        tag: tagName.text,
        text: content.join(""),
    });
}
//# sourceMappingURL=parser.js.map