"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.discoverSignatureComment = exports.discoverComment = void 0;
const ts = require("typescript");
const models_1 = require("../../models");
// Note: This does NOT include JSDoc syntax kinds. This is important!
// Comments from @typedef and @callback tags are handled specially by
// the JSDoc converter because we only want part of the comment when
// getting them.
const wantedKinds = {
    [models_1.ReflectionKind.Project]: [ts.SyntaxKind.SourceFile],
    [models_1.ReflectionKind.Module]: [ts.SyntaxKind.SourceFile],
    [models_1.ReflectionKind.Namespace]: [
        ts.SyntaxKind.ModuleDeclaration,
        ts.SyntaxKind.SourceFile,
    ],
    [models_1.ReflectionKind.Enum]: [
        ts.SyntaxKind.EnumDeclaration,
        ts.SyntaxKind.VariableDeclaration,
    ],
    [models_1.ReflectionKind.EnumMember]: [
        ts.SyntaxKind.EnumMember,
        // This is here so that @enum gets it
        ts.SyntaxKind.PropertyAssignment,
    ],
    [models_1.ReflectionKind.Variable]: [ts.SyntaxKind.VariableDeclaration],
    // Intentionally nothing here, comments will be placed on signatures.
    [models_1.ReflectionKind.Function]: [],
    [models_1.ReflectionKind.Class]: [ts.SyntaxKind.ClassDeclaration],
    [models_1.ReflectionKind.Interface]: [ts.SyntaxKind.InterfaceDeclaration],
    // Intentionally nothing here, comments will be placed on signatures.
    [models_1.ReflectionKind.Constructor]: [],
    [models_1.ReflectionKind.Property]: [
        ts.SyntaxKind.PropertyDeclaration,
        ts.SyntaxKind.PropertySignature,
        ts.SyntaxKind.BinaryExpression,
    ],
    // Intentionally nothing here, comments will be placed on signatures.
    [models_1.ReflectionKind.Method]: [],
    [models_1.ReflectionKind.CallSignature]: [
        ts.SyntaxKind.FunctionDeclaration,
        ts.SyntaxKind.VariableDeclaration,
        ts.SyntaxKind.MethodDeclaration,
        ts.SyntaxKind.MethodDeclaration,
        ts.SyntaxKind.PropertyDeclaration,
        ts.SyntaxKind.PropertySignature,
        ts.SyntaxKind.CallSignature,
    ],
    [models_1.ReflectionKind.IndexSignature]: [ts.SyntaxKind.IndexSignature],
    [models_1.ReflectionKind.ConstructorSignature]: [ts.SyntaxKind.ConstructSignature],
    [models_1.ReflectionKind.Parameter]: [ts.SyntaxKind.Parameter],
    [models_1.ReflectionKind.TypeLiteral]: [ts.SyntaxKind.TypeLiteral],
    [models_1.ReflectionKind.TypeParameter]: [ts.SyntaxKind.TypeParameter],
    [models_1.ReflectionKind.Accessor]: [
        ts.SyntaxKind.GetAccessor,
        ts.SyntaxKind.SetAccessor,
    ],
    [models_1.ReflectionKind.GetSignature]: [ts.SyntaxKind.GetAccessor],
    [models_1.ReflectionKind.SetSignature]: [ts.SyntaxKind.SetAccessor],
    [models_1.ReflectionKind.ObjectLiteral]: [ts.SyntaxKind.ObjectLiteralExpression],
    [models_1.ReflectionKind.TypeAlias]: [ts.SyntaxKind.TypeAliasDeclaration],
    [models_1.ReflectionKind.Event]: [],
    [models_1.ReflectionKind.Reference]: [
        ts.SyntaxKind.NamespaceExport,
        ts.SyntaxKind.ExportSpecifier,
    ],
};
function discoverComment(symbol, kind) {
    var _a;
    // For a module comment, we want the first one defined in the file,
    // not the last one, since that will apply to the import or declaration.
    const reverse = (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.some(ts.isSourceFile);
    for (const decl of symbol.declarations || []) {
        const text = decl.getSourceFile().text;
        if (wantedKinds[kind].includes(decl.kind)) {
            const node = declarationToCommentNode(decl);
            if (!node) {
                continue;
            }
            const comments = ts.getLeadingCommentRanges(text, node.pos);
            if (reverse) {
                comments === null || comments === void 0 ? void 0 : comments.reverse();
            }
            const lastDocComment = comments === null || comments === void 0 ? void 0 : comments.find((c) => text[c.pos] === "/" &&
                text[c.pos + 1] === "*" &&
                text[c.pos + 2] === "*");
            if (lastDocComment) {
                return [decl.getSourceFile(), lastDocComment];
            }
        }
    }
}
exports.discoverComment = discoverComment;
function discoverSignatureComment(declaration) {
    const node = declarationToCommentNode(declaration);
    if (!node) {
        return;
    }
    const text = node.getSourceFile().text;
    const comments = ts.getLeadingCommentRanges(text, node.pos);
    const comment = comments === null || comments === void 0 ? void 0 : comments.find((c) => text[c.pos] === "/" &&
        text[c.pos + 1] === "*" &&
        text[c.pos + 2] === "*");
    if (comment) {
        return [node.getSourceFile(), comment];
    }
}
exports.discoverSignatureComment = discoverSignatureComment;
/**
 * Check whether the given module declaration is the topmost.
 *
 * This function returns TRUE if there is no trailing module defined, in
 * the following example this would be the case only for module <code>C</code>.
 *
 * ```
 * module A.B.C { }
 * ```
 *
 * @param node  The module definition that should be tested.
 * @return TRUE if the given node is the topmost module declaration, FALSE otherwise.
 */
function isTopmostModuleDeclaration(node) {
    return node.getChildren().some(ts.isModuleBlock);
}
/**
 * Return the root module declaration of the given module declaration.
 *
 * In the following example this function would always return module
 * <code>A</code> no matter which of the modules was passed in.
 *
 * ```
 * module A.B.C { }
 * ```
 */
function getRootModuleDeclaration(node) {
    while (node.parent &&
        node.parent.kind === ts.SyntaxKind.ModuleDeclaration) {
        const parent = node.parent;
        if (node.name.pos === parent.name.end + 1) {
            node = parent;
        }
        else {
            break;
        }
    }
    return node;
}
function declarationToCommentNode(node) {
    var _a;
    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.VariableDeclarationList) {
        return node.parent.parent;
    }
    if (node.kind === ts.SyntaxKind.ModuleDeclaration) {
        if (!isTopmostModuleDeclaration(node)) {
            return;
        }
        else {
            return getRootModuleDeclaration(node);
        }
    }
    if (node.kind === ts.SyntaxKind.ExportSpecifier) {
        return node.parent.parent;
    }
    if ([
        ts.SyntaxKind.NamespaceExport,
        ts.SyntaxKind.FunctionExpression,
        ts.SyntaxKind.FunctionType,
        ts.SyntaxKind.FunctionType,
        ts.SyntaxKind.ArrowFunction,
    ].includes(node.kind)) {
        return node.parent;
    }
    return node;
}
//# sourceMappingURL=discovery.js.map