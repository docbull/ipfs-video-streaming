'use strict';

var fs = require('fs');
var debug = require('debug');
var utils = require('../utils.js');
var IPFS = require('ipfs-core');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var IPFS__namespace = /*#__PURE__*/_interopNamespace(IPFS);

const log = debug__default["default"]('ipfs:cli:init');
const keyTypes = {
  ed25519: 'Ed25519',
  rsa: 'RSA',
  secp256k1: 'secp256k1'
};
var init = {
  command: 'init [default-config] [options]',
  describe: 'Initialize a local IPFS node\n\n' + 'If you are going to run IPFS in a server environment, you may want to ' + 'initialize it using the \'server\' profile.\n\n' + 'For the list of available profiles run `jsipfs config profile ls`',
  builder(yargs) {
    return yargs.epilog(utils.ipfsPathHelp).positional('default-config', {
      describe: 'Node config, this should be a path to a file or JSON and will be merged with the default config. See https://github.com/ipfs/js-ipfs#optionsconfig',
      type: 'string'
    }).option('algorithm', {
      type: 'string',
      choices: Object.keys(keyTypes),
      alias: 'a',
      default: 'ed25519',
      describe: 'Cryptographic algorithm to use for key generation'
    }).option('bits', {
      type: 'number',
      alias: 'b',
      default: '2048',
      describe: 'Number of bits to use if the generated private key is RSA (defaults to 2048)',
      coerce: Number
    }).option('empty-repo', {
      alias: 'e',
      type: 'boolean',
      describe: 'Don\'t add and pin help files to the local storage'
    }).option('private-key', {
      alias: 'k',
      type: 'string',
      describe: 'Pre-generated private key to use for the repo'
    }).option('profile', {
      alias: 'p',
      type: 'string',
      describe: 'Apply profile settings to config. Multiple profiles can be separated by \',\'',
      coerce: value => {
        return (value || '').split(',');
      }
    });
  },
  async handler(argv) {
    const {print, repoPath} = argv.ctx;
    let config = {};
    if (argv.defaultConfig) {
      try {
        const raw = fs__default["default"].readFileSync(argv.defaultConfig, { encoding: 'utf8' });
        config = JSON.parse(raw);
      } catch (error) {
        log(error);
        throw new Error('Default config couldn\'t be found or content isn\'t valid JSON.');
      }
    }
    print(`initializing ipfs node at ${ repoPath }`);
    try {
      await IPFS__namespace.create({
        repo: repoPath,
        init: {
          algorithm: keyTypes[argv.algorithm],
          bits: argv.bits,
          privateKey: argv.privateKey,
          emptyRepo: argv.emptyRepo,
          profiles: argv.profile
        },
        pass: argv.pass,
        start: false,
        config
      });
    } catch (err) {
      if (err.code === 'EACCES') {
        err.message = 'EACCES: permission denied, stat $IPFS_PATH/version';
      }
      throw err;
    }
  }
};

module.exports = init;
