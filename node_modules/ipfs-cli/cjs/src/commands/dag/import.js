'use strict';

var fs = require('fs');
var parseDuration = require('parse-duration');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);

var dagImport = {
  command: 'import [path...]',
  describe: 'Import the contents of one or more CARs from files or stdin',
  builder: {
    'pin-roots': {
      type: 'boolean',
      default: true,
      describe: 'Pin optional roots listed in the CAR headers after importing.'
    },
    'cid-base': {
      describe: 'Number base to display CIDs in.',
      type: 'string',
      default: 'base58btc'
    },
    timeout: {
      type: 'string',
      coerce: parseDuration__default["default"]
    }
  },
  async handler({
    ctx: {ipfs, print, getStdin},
    path,
    pinRoots,
    timeout,
    cidBase
  }) {
    const handleResult = async ({root}) => {
      const base = await ipfs.bases.getBase(cidBase);
      print(`pinned root\t${ root.cid.toString(base.encoder) }\t${ root.pinErrorMsg || 'success' }`);
    };
    const options = {
      timeout,
      pinRoots
    };
    if (path) {
      for await (const result of ipfs.dag.import(fromFiles(print, path), options)) {
        await handleResult(result);
      }
    } else {
      print('importing CAR from stdin...');
      for await (const result of ipfs.dag.import([getStdin()], options)) {
        await handleResult(result);
      }
    }
  }
};
function* fromFiles(print, paths) {
  for (const path of paths) {
    print(`importing from ${ path }...`);
    yield fs__default["default"].createReadStream(path);
  }
}

module.exports = dagImport;
