'use strict';

var dagCBOR = require('@ipld/dag-cbor');
var dagPB = require('@ipld/dag-pb');
var dagJSON = require('@ipld/dag-json');
var raw = require('multiformats/codecs/raw');
var concat = require('it-concat');
var parseDuration = require('parse-duration');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var dagCBOR__namespace = /*#__PURE__*/_interopNamespace(dagCBOR);
var dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);
var dagJSON__namespace = /*#__PURE__*/_interopNamespace(dagJSON);
var raw__namespace = /*#__PURE__*/_interopNamespace(raw);
var concat__default = /*#__PURE__*/_interopDefaultLegacy(concat);
var parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);

const codecs = [
  dagCBOR__namespace,
  dagJSON__namespace,
  dagPB__namespace,
  raw__namespace
].reduce((m, codec) => {
  m[codec.name] = codec;
  return m;
}, {});
var dagPut = {
  command: 'put [data]',
  describe: 'accepts input from a file or stdin and parses it into an object of the specified format',
  builder: {
    data: { type: 'string' },
    'store-codec': {
      type: 'string',
      default: 'dag-cbor',
      describe: 'The codec that the stored object will be encoded with',
      choices: [
        'dag-cbor',
        'dag-json',
        'dag-pb',
        'raw'
      ]
    },
    'input-codec': {
      type: 'string',
      default: 'dag-json',
      describe: 'The codec that the input object is encoded with',
      choices: [
        'dag-cbor',
        'dag-json',
        'dag-pb',
        'raw'
      ]
    },
    pin: {
      type: 'boolean',
      default: true,
      describe: 'Pin this object when adding'
    },
    'hash-alg': {
      type: 'string',
      alias: 'hash',
      default: 'sha2-256',
      describe: 'Hash function to use'
    },
    'cid-version': {
      type: 'integer',
      describe: 'CID version. Defaults to 0 unless an option that depends on CIDv1 is passed',
      default: 0
    },
    'cid-base': {
      describe: 'Number base to display CIDs in.',
      type: 'string',
      default: 'base58btc'
    },
    preload: {
      type: 'boolean',
      default: true,
      describe: 'Preload this object when adding'
    },
    'only-hash': {
      type: 'boolean',
      default: false,
      describe: 'Only hash the content, do not write to the underlying block store'
    },
    timeout: {
      type: 'string',
      coerce: parseDuration__default["default"]
    }
  },
  async handler({
    ctx: {ipfs, print, getStdin},
    data,
    inputCodec,
    storeCodec,
    pin,
    hashAlg,
    cidVersion,
    cidBase,
    preload,
    onlyHash,
    timeout
  }) {
    if (!codecs[inputCodec]) {
      throw new Error(`Unknown input-codec ${ inputCodec }`);
    }
    if (storeCodec !== 'dag-pb') {
      cidVersion = 1;
    }
    let source;
    if (!data) {
      source = (await concat__default["default"](getStdin(), { type: 'buffer' })).slice();
    } else {
      source = Buffer.from(data);
    }
    const node = codecs[inputCodec].decode(source);
    const cid = await ipfs.dag.put(node, {
      storeCodec,
      hashAlg,
      version: cidVersion,
      onlyHash,
      preload,
      pin,
      timeout
    });
    const base = await ipfs.bases.getBase(cidBase);
    print(cid.toString(base.encoder));
  }
};

module.exports = dagPut;
