'use strict';

var fs = require('fs');
var path = require('path');
var toIterable = require('stream-to-it');
var itPipe = require('it-pipe');
var parseDuration = require('parse-duration');
var utils = require('../utils.js');
var itTar = require('it-tar');
var map = require('it-map');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var toIterable__default = /*#__PURE__*/_interopDefaultLegacy(toIterable);
var parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);

var get = {
  command: 'get <ipfsPath>',
  describe: 'Download IPFS objects',
  builder: {
    output: {
      alias: 'o',
      type: 'string',
      default: process.cwd()
    },
    force: {
      alias: 'f',
      type: 'boolean',
      default: false
    },
    timeout: {
      type: 'string',
      coerce: parseDuration__default["default"]
    },
    archive: {
      alias: 'a',
      type: 'boolean',
      desc: 'Output a TAR archive'
    },
    compress: {
      alias: 'C',
      type: 'boolean',
      desc: 'Compress the output with GZIP compression'
    },
    compressionLevel: {
      alias: [
        'l',
        'compression-level'
      ],
      type: 'number',
      desc: 'The level of compression (-1-9)',
      default: 6
    }
  },
  async handler({
    ctx: {ipfs, print},
    ipfsPath,
    output,
    force,
    timeout,
    archive,
    compress,
    compressionLevel
  }) {
    print(`Saving file(s) ${ utils.stripControlCharacters(ipfsPath) }`);
    if (output.substring(0, output.length) !== output && !force) {
      throw new Error(`File prefix invalid, would write to files outside of ${ output }, pass --force to override`);
    }
    if (archive || compress) {
      if (output === process.cwd()) {
        output = path__default["default"].join(output, ipfsPath);
      }
      await fs__default["default"].promises.mkdir(path__default["default"].dirname(output), { recursive: true });
      await itPipe.pipe(ipfs.get(ipfsPath, {
        timeout,
        archive,
        compress,
        compressionLevel
      }), toIterable__default["default"].sink(fs__default["default"].createWriteStream(output)));
      return;
    }
    await itPipe.pipe(ipfs.get(ipfsPath, {
      timeout,
      archive,
      compress,
      compressionLevel
    }), itTar.extract(), async function extractTarball(source) {
      for await (const {header, body} of source) {
        const outputPath = path__default["default"].join(output, header.name);
        if (outputPath.substring(0, output.length) !== output && !force) {
          throw new Error(`File prefix invalid, would write to files outside of ${ output }, pass --force to override`);
        }
        if (header.type === 'file') {
          await fs__default["default"].promises.mkdir(path__default["default"].dirname(outputPath), { recursive: true });
          await itPipe.pipe(body, source => map__default["default"](source, buf => buf.slice()), toIterable__default["default"].sink(fs__default["default"].createWriteStream(outputPath)));
        } else if (header.type === 'directory') {
          await fs__default["default"].promises.mkdir(outputPath, { recursive: true });
        } else {
          throw new Error(`Unknown tar entry type ${ header.type }`);
        }
        await fs__default["default"].promises.chmod(outputPath, header.mode);
        await fs__default["default"].promises.utimes(outputPath, header.mtime, header.mtime);
      }
    });
  }
};

module.exports = get;
