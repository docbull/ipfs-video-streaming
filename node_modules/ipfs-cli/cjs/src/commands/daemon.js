'use strict';

var os = require('os');
var fs = require('fs');
var toUri = require('multiaddr-to-uri');
var utils = require('../utils.js');
var env_js = require('ipfs-utils/src/env.js');
var debug = require('debug');
var ipfsDaemon = require('ipfs-daemon');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var toUri__default = /*#__PURE__*/_interopDefaultLegacy(toUri);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = debug__default["default"]('ipfs:cli:daemon');
var daemon = {
  command: 'daemon',
  describe: 'Start a long-running daemon process',
  builder(yargs) {
    return yargs.epilog(utils.ipfsPathHelp).option('init-config', {
      type: 'string',
      desc: 'Path to existing configuration file to be loaded during --init.'
    }).option('init-profile', {
      type: 'string',
      desc: 'Configuration profiles to apply for --init. See ipfs init --help for more.',
      coerce: value => {
        return (value || '').split(',');
      }
    }).option('enable-sharding-experiment', {
      type: 'boolean',
      default: false
    }).option('offline', {
      type: 'boolean',
      desc: 'Run offline. Do not connect to the rest of the network but provide local API.',
      default: false
    }).option('enable-namesys-pubsub', {
      type: 'boolean',
      default: false
    }).option('enable-preload', {
      type: 'boolean',
      default: !env_js.isTest
    });
  },
  async handler(argv) {
    const {print, repoPath} = argv.ctx;
    print('Initializing IPFS daemon...');
    print(`System version: ${ os__default["default"].arch() }/${ os__default["default"].platform() }`);
    print(`Node.js version: ${ process.versions.node }`);
    let config = {};
    if (argv.initConfig) {
      try {
        const raw = fs__default["default"].readFileSync(argv.initConfig, { encoding: 'utf8' });
        config = JSON.parse(raw);
      } catch (error) {
        log(error);
        throw new Error('Default config couldn\'t be found or content isn\'t valid JSON.');
      }
    }
    const daemon = new ipfsDaemon.Daemon({
      config,
      silent: argv.silent,
      repo: process.env.IPFS_PATH,
      repoAutoMigrate: argv.migrate,
      offline: argv.offline,
      pass: argv.pass,
      preload: { enabled: argv.enablePreload },
      EXPERIMENTAL: {
        ipnsPubsub: argv.enableNamesysPubsub,
        sharding: argv.enableShardingExperiment
      },
      init: argv.initProfile ? { profiles: argv.initProfile } : undefined
    });
    try {
      await daemon.start();
      const version = await daemon._ipfs.version();
      print(`js-ipfs version: ${ version.version }`);
      if (daemon._httpApi && daemon._httpApi._apiServers) {
        daemon._httpApi._apiServers.forEach(apiServer => {
          print(`HTTP API listening on ${ apiServer.info.ma }`);
        });
      }
      if (daemon._grpcServer && daemon._grpcServer) {
        print(`gRPC listening on ${ daemon._grpcServer.info.ma }`);
      }
      if (daemon._httpGateway && daemon._httpGateway._gatewayServers) {
        daemon._httpGateway._gatewayServers.forEach(gatewayServer => {
          print(`Gateway (read only) listening on ${ gatewayServer.info.ma }`);
        });
      }
      if (daemon._httpApi && daemon._httpApi._apiServers) {
        daemon._httpApi._apiServers.forEach(apiServer => {
          print(`Web UI available at ${ toUri__default["default"](apiServer.info.ma) }/webui`);
        });
      }
    } catch (err) {
      if (err.code === 'ERR_REPO_NOT_INITIALIZED' || err.message.match(/uninitialized/i)) {
        err.message = 'no initialized ipfs repo found in ' + repoPath + '\nplease run: jsipfs init';
      }
      throw err;
    }
    print('Daemon is ready');
    const cleanup = async () => {
      print('Received interrupt signal, shutting down...');
      await daemon.stop();
      process.exit(0);
    };
    process.on('SIGTERM', cleanup);
    process.on('SIGINT', cleanup);
    process.on('SIGHUP', cleanup);
  }
};

module.exports = daemon;
