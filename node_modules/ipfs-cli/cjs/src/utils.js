'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var os = require('os');
var path = require('path');
var debug = require('debug');
var Progress = require('progress');
var byteman = require('byteman');
var IPFS = require('ipfs-core');
var cid = require('multiformats/cid');
var multiaddr = require('multiaddr');
var fromString = require('uint8arrays/from-string');
var ipfsHttpClient = require('ipfs-http-client');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var Progress__default = /*#__PURE__*/_interopDefaultLegacy(Progress);
var byteman__default = /*#__PURE__*/_interopDefaultLegacy(byteman);

const log = debug__default["default"]('ipfs:cli:utils');
const getRepoPath = () => {
  return process.env.IPFS_PATH || path__default["default"].join(os__default["default"].homedir(), '/.jsipfs');
};
const isDaemonOn = () => {
  try {
    fs__default["default"].readFileSync(path__default["default"].join(getRepoPath(), 'api'));
    log('daemon is on');
    return true;
  } catch (err) {
    log('daemon is off');
    return false;
  }
};
let visible = true;
const disablePrinting = () => {
  visible = false;
};
const print = (msg, includeNewline = true, isError = false) => {
  if (visible) {
    if (msg === undefined) {
      msg = '';
    }
    msg = msg.toString();
    msg = includeNewline ? msg + '\n' : msg;
    const outStream = isError ? process.stderr : process.stdout;
    outStream.write(msg);
  }
};
print.clearLine = () => {
  return process.stdout.clearLine(0);
};
print.cursorTo = pos => {
  process.stdout.cursorTo(pos);
};
print.write = data => {
  process.stdout.write(data);
};
print.error = (msg, newline = true) => {
  print(msg, newline, true);
};
print.isTTY = process.stdout.isTTY;
print.columns = process.stdout.columns;
const createProgressBar = (totalBytes, output) => {
  const total = byteman__default["default"](totalBytes, 2, 'MB');
  const barFormat = `:progress / ${ total } [:bar] :percent :etas`;
  return new Progress__default["default"](barFormat, {
    incomplete: ' ',
    clear: true,
    stream: output,
    total: totalBytes
  });
};
const rightpad = (val, n) => {
  let result = String(val);
  for (let i = result.length; i < n; ++i) {
    result += ' ';
  }
  return result;
};
const ipfsPathHelp = 'ipfs uses a repository in the local file system. By default, the repo is ' + 'located at ~/.jsipfs. To change the repo location, set the $IPFS_PATH environment variable:\n\n' + 'export IPFS_PATH=/path/to/ipfsrepo\n';
async function getIpfs(argv) {
  if (!argv.api && !isDaemonOn()) {
    const ipfs = await IPFS.create({
      silent: argv.silent,
      repoAutoMigrate: argv.migrate,
      repo: getRepoPath(),
      init: { allowNew: false },
      start: false,
      pass: argv.pass
    });
    return {
      isDaemon: false,
      ipfs,
      cleanup: async () => {
        await ipfs.stop();
      }
    };
  }
  let endpoint = null;
  if (!argv.api) {
    const apiPath = path__default["default"].join(getRepoPath(), 'api');
    endpoint = fs__default["default"].readFileSync(apiPath).toString();
  } else {
    endpoint = argv.api;
  }
  const ipfs = ipfsHttpClient.create({ url: endpoint });
  return {
    isDaemon: true,
    ipfs,
    cleanup: async () => {
    }
  };
}
const asBoolean = value => {
  if (value === false || value === true) {
    return value;
  }
  if (value === undefined) {
    return true;
  }
  return false;
};
const asOctal = value => {
  return parseInt(value, 8);
};
const asMtimeFromSeconds = (secs, nsecs) => {
  if (secs == null) {
    return undefined;
  }
  return {
    secs,
    nsecs
  };
};
const coerceMtime = value => {
  value = parseInt(value);
  if (isNaN(value)) {
    throw new Error('mtime must be a number');
  }
  return value;
};
const coerceMtimeNsecs = value => {
  value = parseInt(value);
  if (isNaN(value)) {
    throw new Error('mtime-nsecs must be a number');
  }
  if (value < 0 || value > 999999999) {
    throw new Error('mtime-nsecs must be in the range [0,999999999]');
  }
  return value;
};
const coerceCID = value => {
  if (!value) {
    return undefined;
  }
  if (value.startsWith('/ipfs/')) {
    return cid.CID.parse(value.split('/')[2]);
  }
  return cid.CID.parse(value);
};
const coerceCIDs = values => {
  if (values == null) {
    return [];
  }
  return values.map(coerceCID).filter(Boolean);
};
const coerceMultiaddr = value => {
  if (value == null) {
    return undefined;
  }
  return new multiaddr.Multiaddr(value);
};
const coerceMultiaddrs = values => {
  if (values == null) {
    return undefined;
  }
  return values.map(coerceMultiaddr).filter(Boolean);
};
const coerceUint8Array = value => {
  if (value == null) {
    return undefined;
  }
  return fromString.fromString(value);
};
const DEL = 127;
const stripControlCharacters = str => {
  return (str || '').split('').filter(c => {
    const charCode = c.charCodeAt(0);
    return charCode > 31 && charCode !== DEL;
  }).join('');
};
const escapeControlCharacters = str => {
  const escapes = {
    '00': '\\0',
    '08': '\\b',
    '09': '\\t',
    '0A': '\\n',
    '0B': '\\v',
    '0C': '\\f',
    '0D': '\\r'
  };
  return (str || '').split('').map(c => {
    const charCode = c.charCodeAt(0);
    if (charCode > 31 && charCode !== DEL) {
      return c;
    }
    const hex = Number(c).toString(16).padStart(2, '0');
    return escapes[hex] || `\\x${ hex }`;
  }).join('');
};
const makeEntriesPrintable = (obj, cidBase) => {
  const cid$1 = cid.CID.asCID(obj);
  if (cid$1) {
    return { '/': cid$1.toString(cidBase.encoder) };
  }
  if (typeof obj === 'string') {
    return stripControlCharacters(obj);
  }
  if (typeof obj === 'number' || obj == null || obj === true || obj === false) {
    return obj;
  }
  if (Array.isArray(obj)) {
    const output = [];
    for (const key of obj) {
      output.push(makeEntriesPrintable(key, cidBase));
    }
    return output;
  }
  const output = {};
  Object.entries(obj).forEach(([key, value]) => {
    const outputKey = stripControlCharacters(key);
    output[outputKey] = makeEntriesPrintable(value, cidBase);
  });
  return output;
};

exports.asBoolean = asBoolean;
exports.asMtimeFromSeconds = asMtimeFromSeconds;
exports.asOctal = asOctal;
exports.coerceCID = coerceCID;
exports.coerceCIDs = coerceCIDs;
exports.coerceMtime = coerceMtime;
exports.coerceMtimeNsecs = coerceMtimeNsecs;
exports.coerceMultiaddr = coerceMultiaddr;
exports.coerceMultiaddrs = coerceMultiaddrs;
exports.coerceUint8Array = coerceUint8Array;
exports.createProgressBar = createProgressBar;
exports.disablePrinting = disablePrinting;
exports.escapeControlCharacters = escapeControlCharacters;
exports.getIpfs = getIpfs;
exports.getRepoPath = getRepoPath;
exports.ipfsPathHelp = ipfsPathHelp;
exports.isDaemonOn = isDaemonOn;
exports.makeEntriesPrintable = makeEntriesPrintable;
exports.print = print;
exports.rightpad = rightpad;
exports.stripControlCharacters = stripControlCharacters;
