import split from 'it-split';
import { CID } from 'multiformats/cid';
export default {
  command: 'format [cids...]',
  describe: 'Format and convert a CID in various useful ways.',
  builder: {
    format: {
      describe: `Printf style format string:

%% literal %
%b multibase name
%B multibase code
%v version string
%V version number
%c codec name
%C codec code
%h multihash name
%H multihash code
%L hash digest length
%m multihash encoded in base %b (with multibase prefix)
%M multihash encoded in base %b without multibase prefix
%d hash digest encoded in base %b (with multibase prefix)
%D hash digest encoded in base %b without multibase prefix
%s cid string encoded in base %b (1)
%S cid string encoded in base %b without multibase prefix
%P cid prefix: %v-%c-%h-%L

(1) For CID version 0 the multibase must be base58btc and no prefix is used. For Cid version 1 the multibase prefix is included.`,
      alias: 'f',
      type: 'string',
      default: '%s'
    },
    'cid-version': {
      describe: 'CID version to convert to.',
      alias: 'v',
      type: 'number'
    },
    base: {
      describe: 'Multibase to display output in.',
      alias: 'b',
      type: 'string'
    }
  },
  async handler({
    ctx: {ipfs, print, getStdin},
    cids,
    format,
    cidVersion,
    base
  }) {
    let input;
    if (cids && cids.length) {
      input = cids;
    } else {
      input = split(getStdin());
    }
    let formatStr = format || '%s';
    if (formatStr === 'prefix') {
      formatStr = '%P';
    }
    if (typeof formatStr !== 'string' || formatStr.indexOf('%') === -1) {
      throw new Error(`invalid format string: ${ formatStr }`);
    }
    for await (const data of input) {
      const str = data.toString().trim();
      if (!str) {
        continue;
      }
      let cid = CID.parse(str);
      if (cidVersion != null && cid.version !== cidVersion) {
        if (cidVersion === 0) {
          cid = cid.toV0();
        } else if (cidVersion === 1) {
          cid = cid.toV1();
        } else {
          throw new Error(`invalid cid version: ${ cidVersion }`);
        }
      }
      let cidBase = findBase(str, ipfs);
      if (base) {
        const foundBase = ipfs.bases.listBases().find(b => b.name === base);
        if (!foundBase) {
          throw new Error(`invalid base prefix: ${ str.substring(0, 1) }`);
        }
        cidBase = foundBase;
      }
      print(formatStr.replace(/%([a-zA-Z%])/g, replacer(cid, cidBase, ipfs)));
    }
  }
};
function replacer(cid, base, ipfs) {
  const replace = (match, specifier) => {
    switch (specifier) {
    case '%':
      return '%';
    case 'b':
      return base.name;
    case 'B':
      return base.prefix;
    case 'v':
      return `cidv${ cid.version }`;
    case 'V':
      return cid.version.toString();
    case 'c':
      return findCodec(cid, ipfs).name;
    case 'C':
      return cid.code;
    case 'h':
      return findHasher(cid, ipfs).name;
    case 'H':
      return findHasher(cid, ipfs).code;
    case 'L':
      return cid.multihash.size.toString();
    case 'm':
      return base.encoder.encode(cid.multihash.bytes);
    case 'M':
      return base.encoder.encode(cid.multihash.bytes).substring(1);
    case 'd':
      return base.encoder.encode(cid.multihash.digest);
    case 'D':
      return base.encoder.encode(cid.multihash.digest).substring(1);
    case 's':
      return base.encoder.encode(cid.bytes).slice(cid.version === 0 && base.name === 'base58btc' ? 1 : 0);
    case 'S':
      return base.encoder.encode(cid.bytes).slice(1);
    case 'P':
      return prefix(cid, ipfs);
    default:
      throw new Error(`unrecognized specifier in format string: ${ specifier }`);
    }
  };
  return replace;
}
function findBase(str, ipfs) {
  if (CID.parse(str).version === 0) {
    str = `z${ str }`;
  }
  const prefix = str.substring(0, 1);
  const base = ipfs.bases.listBases().find(b => b.prefix === prefix);
  if (!base) {
    throw new Error(`invalid base prefix: ${ str.substring(0, 1) }`);
  }
  return base;
}
function findCodec(cid, ipfs) {
  const codec = ipfs.codecs.listCodecs().find(c => c.code === cid.code);
  if (!codec) {
    throw new Error(`invalid codec: ${ cid.code }`);
  }
  return codec;
}
function findHasher(cid, ipfs) {
  const codec = ipfs.hashers.listHashers().find(h => h.code === cid.multihash.code);
  if (!codec) {
    throw new Error(`invalid codec: ${ cid.code }`);
  }
  return codec;
}
function prefix(cid, ipfs) {
  const hasher = findHasher(cid, ipfs);
  const codec = findCodec(cid, ipfs);
  return `cidv${ cid.version }-${ codec.name }-${ hasher.name }-${ cid.multihash.size }`;
}