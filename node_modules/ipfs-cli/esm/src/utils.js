import fs from 'fs';
import os from 'os';
import path from 'path';
import debug from 'debug';
import Progress from 'progress';
import byteman from 'byteman';
import { create } from 'ipfs-core';
import { CID } from 'multiformats/cid';
import { Multiaddr } from 'multiaddr';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { create as httpClient } from 'ipfs-http-client';
const log = debug('ipfs:cli:utils');
export const getRepoPath = () => {
  return process.env.IPFS_PATH || path.join(os.homedir(), '/.jsipfs');
};
export const isDaemonOn = () => {
  try {
    fs.readFileSync(path.join(getRepoPath(), 'api'));
    log('daemon is on');
    return true;
  } catch (err) {
    log('daemon is off');
    return false;
  }
};
let visible = true;
export const disablePrinting = () => {
  visible = false;
};
export const print = (msg, includeNewline = true, isError = false) => {
  if (visible) {
    if (msg === undefined) {
      msg = '';
    }
    msg = msg.toString();
    msg = includeNewline ? msg + '\n' : msg;
    const outStream = isError ? process.stderr : process.stdout;
    outStream.write(msg);
  }
};
print.clearLine = () => {
  return process.stdout.clearLine(0);
};
print.cursorTo = pos => {
  process.stdout.cursorTo(pos);
};
print.write = data => {
  process.stdout.write(data);
};
print.error = (msg, newline = true) => {
  print(msg, newline, true);
};
print.isTTY = process.stdout.isTTY;
print.columns = process.stdout.columns;
export const createProgressBar = (totalBytes, output) => {
  const total = byteman(totalBytes, 2, 'MB');
  const barFormat = `:progress / ${ total } [:bar] :percent :etas`;
  return new Progress(barFormat, {
    incomplete: ' ',
    clear: true,
    stream: output,
    total: totalBytes
  });
};
export const rightpad = (val, n) => {
  let result = String(val);
  for (let i = result.length; i < n; ++i) {
    result += ' ';
  }
  return result;
};
export const ipfsPathHelp = 'ipfs uses a repository in the local file system. By default, the repo is ' + 'located at ~/.jsipfs. To change the repo location, set the $IPFS_PATH environment variable:\n\n' + 'export IPFS_PATH=/path/to/ipfsrepo\n';
export async function getIpfs(argv) {
  if (!argv.api && !isDaemonOn()) {
    const ipfs = await create({
      silent: argv.silent,
      repoAutoMigrate: argv.migrate,
      repo: getRepoPath(),
      init: { allowNew: false },
      start: false,
      pass: argv.pass
    });
    return {
      isDaemon: false,
      ipfs,
      cleanup: async () => {
        await ipfs.stop();
      }
    };
  }
  let endpoint = null;
  if (!argv.api) {
    const apiPath = path.join(getRepoPath(), 'api');
    endpoint = fs.readFileSync(apiPath).toString();
  } else {
    endpoint = argv.api;
  }
  const ipfs = httpClient({ url: endpoint });
  return {
    isDaemon: true,
    ipfs,
    cleanup: async () => {
    }
  };
}
export const asBoolean = value => {
  if (value === false || value === true) {
    return value;
  }
  if (value === undefined) {
    return true;
  }
  return false;
};
export const asOctal = value => {
  return parseInt(value, 8);
};
export const asMtimeFromSeconds = (secs, nsecs) => {
  if (secs == null) {
    return undefined;
  }
  return {
    secs,
    nsecs
  };
};
export const coerceMtime = value => {
  value = parseInt(value);
  if (isNaN(value)) {
    throw new Error('mtime must be a number');
  }
  return value;
};
export const coerceMtimeNsecs = value => {
  value = parseInt(value);
  if (isNaN(value)) {
    throw new Error('mtime-nsecs must be a number');
  }
  if (value < 0 || value > 999999999) {
    throw new Error('mtime-nsecs must be in the range [0,999999999]');
  }
  return value;
};
export const coerceCID = value => {
  if (!value) {
    return undefined;
  }
  if (value.startsWith('/ipfs/')) {
    return CID.parse(value.split('/')[2]);
  }
  return CID.parse(value);
};
export const coerceCIDs = values => {
  if (values == null) {
    return [];
  }
  return values.map(coerceCID).filter(Boolean);
};
export const coerceMultiaddr = value => {
  if (value == null) {
    return undefined;
  }
  return new Multiaddr(value);
};
export const coerceMultiaddrs = values => {
  if (values == null) {
    return undefined;
  }
  return values.map(coerceMultiaddr).filter(Boolean);
};
export const coerceUint8Array = value => {
  if (value == null) {
    return undefined;
  }
  return uint8ArrayFromString(value);
};
const DEL = 127;
export const stripControlCharacters = str => {
  return (str || '').split('').filter(c => {
    const charCode = c.charCodeAt(0);
    return charCode > 31 && charCode !== DEL;
  }).join('');
};
export const escapeControlCharacters = str => {
  const escapes = {
    '00': '\\0',
    '08': '\\b',
    '09': '\\t',
    '0A': '\\n',
    '0B': '\\v',
    '0C': '\\f',
    '0D': '\\r'
  };
  return (str || '').split('').map(c => {
    const charCode = c.charCodeAt(0);
    if (charCode > 31 && charCode !== DEL) {
      return c;
    }
    const hex = Number(c).toString(16).padStart(2, '0');
    return escapes[hex] || `\\x${ hex }`;
  }).join('');
};
export const makeEntriesPrintable = (obj, cidBase) => {
  const cid = CID.asCID(obj);
  if (cid) {
    return { '/': cid.toString(cidBase.encoder) };
  }
  if (typeof obj === 'string') {
    return stripControlCharacters(obj);
  }
  if (typeof obj === 'number' || obj == null || obj === true || obj === false) {
    return obj;
  }
  if (Array.isArray(obj)) {
    const output = [];
    for (const key of obj) {
      output.push(makeEntriesPrintable(key, cidBase));
    }
    return output;
  }
  const output = {};
  Object.entries(obj).forEach(([key, value]) => {
    const outputKey = stripControlCharacters(key);
    output[outputKey] = makeEntriesPrintable(value, cidBase);
  });
  return output;
};