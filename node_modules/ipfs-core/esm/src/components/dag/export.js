import { CID } from 'multiformats/cid';
import { createUnsafe } from 'multiformats/block';
import { CarWriter } from '@ipld/car/writer';
import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';
import debug from 'debug';
import * as raw from 'multiformats/codecs/raw';
import * as json from 'multiformats/codecs/json';
import { walk } from 'multiformats/traversal';
const log = debug('ipfs:components:dag:import');
const NO_LINKS_CODECS = [
  raw.code,
  json.code
];
export function createExport({repo, preload, codecs}) {
  async function* dagExport(root, options = {}) {
    if (options.preload !== false) {
      preload(root);
    }
    const cid = CID.asCID(root);
    if (!cid) {
      throw new Error(`Unexpected error converting CID type: ${ root }`);
    }
    log(`Exporting ${ cid } as car`);
    const {writer, out} = await CarWriter.create([cid]);
    let err = null;
    (async () => {
      try {
        const load = makeLoader(repo, writer, {
          signal: options.signal,
          timeout: options.timeout
        }, codecs);
        await walk({
          cid,
          load
        });
      } catch (e) {
        err = e;
      } finally {
        writer.close();
      }
    })();
    for await (const chunk of out) {
      if (err) {
        break;
      }
      yield chunk;
    }
    if (err) {
      throw err;
    }
  }
  return withTimeoutOption(dagExport);
}
function makeLoader(repo, writer, options, codecs) {
  return async cid => {
    const codec = await codecs.getCodec(cid.code);
    if (!codec) {
      throw new Error(`Can't decode links in block with codec 0x${ cid.code.toString(16) } to form complete DAG`);
    }
    const bytes = await repo.blocks.get(cid, options);
    log(`Adding block ${ cid } to car`);
    await writer.put({
      cid,
      bytes
    });
    if (NO_LINKS_CODECS.includes(cid.code)) {
      return null;
    }
    return createUnsafe({
      bytes,
      cid,
      codec
    });
  };
}