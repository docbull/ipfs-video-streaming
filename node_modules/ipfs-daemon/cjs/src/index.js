'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debug = require('debug');
var set = require('just-safe-set');
var WebRTCStar = require('libp2p-webrtc-star');
var ipfsCore = require('ipfs-core');
var ipfsHttpServer = require('ipfs-http-server');
var ipfsHttpGateway = require('ipfs-http-gateway');
var ipfsGrpcServer = require('ipfs-grpc-server');
var env_js = require('ipfs-utils/src/env.js');
var prometheusClient = require('prom-client');
var Libp2p = require('libp2p');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var set__default = /*#__PURE__*/_interopDefaultLegacy(set);
var WebRTCStar__default = /*#__PURE__*/_interopDefaultLegacy(WebRTCStar);
var prometheusClient__default = /*#__PURE__*/_interopDefaultLegacy(prometheusClient);
var Libp2p__default = /*#__PURE__*/_interopDefaultLegacy(Libp2p);

const log = debug__default["default"]('ipfs:daemon');
class Daemon {
  constructor(options = {}) {
    this._options = options;
    if (process.env.IPFS_MONITORING) {
      prometheusClient__default["default"].collectDefaultMetrics();
    }
    this._ipfs = undefined;
  }
  async start() {
    log('starting');
    this._ipfs = await ipfsCore.create(Object.assign({}, {
      start: true,
      libp2p: getLibp2p
    }, this._options));
    this._httpApi = new ipfsHttpServer.HttpApi(this._ipfs);
    await this._httpApi.start();
    this._httpGateway = new ipfsHttpGateway.HttpGateway(this._ipfs);
    await this._httpGateway.start();
    const config = await this._ipfs.config.getAll();
    if (config.Addresses && config.Addresses.RPC) {
      this._grpcServer = await ipfsGrpcServer.createServer(this._ipfs);
    }
    log('started');
  }
  async stop() {
    log('stopping');
    await Promise.all([
      this._httpApi && this._httpApi.stop(),
      this._httpGateway && this._httpGateway.stop(),
      this._grpcServer && this._grpcServer.stop(),
      this._ipfs && this._ipfs.stop()
    ]);
    log('stopped');
  }
}
async function getLibp2p({libp2pOptions}) {
  let electronWebRTC;
  let wrtc;
  if (env_js.isElectron) {
    try {
      electronWebRTC = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('electron-webrtc')); })();
    } catch (err) {
      log('failed to load optional electron-webrtc dependency');
    }
  }
  if (!electronWebRTC) {
    try {
      wrtc = (await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('wrtc')); })).default;
    } catch (err) {
      log('failed to load optional webrtc dependency');
    }
  }
  if (wrtc || electronWebRTC) {
    log(`Using ${ wrtc ? 'wrtc' : 'electron-webrtc' } for webrtc support`);
    set__default["default"](libp2pOptions, 'config.transport.WebRTCStar.wrtc', wrtc || electronWebRTC);
    libp2pOptions.modules.transport.push(WebRTCStar__default["default"]);
  }
  return Libp2p__default["default"].create(libp2pOptions);
}

exports.Daemon = Daemon;
