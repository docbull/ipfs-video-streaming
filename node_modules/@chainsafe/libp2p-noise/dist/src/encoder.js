"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode2 = exports.decode1 = exports.decode0 = exports.encode2 = exports.encode1 = exports.encode0 = exports.uint16BEDecode = exports.uint16BEEncode = void 0;
const BufferList_1 = __importDefault(require("bl/BufferList"));
const concat_1 = require("uint8arrays/concat");
const allocUnsafe = (len) => {
    if (globalThis.Buffer) {
        return globalThis.Buffer.allocUnsafe(len);
    }
    return new Uint8Array(len);
};
const uint16BEEncode = (value, target, offset) => {
    target = target || allocUnsafe(2);
    new DataView(target.buffer, target.byteOffset, target.byteLength).setUint16(offset, value, false);
    return target;
};
exports.uint16BEEncode = uint16BEEncode;
exports.uint16BEEncode.bytes = 2;
const uint16BEDecode = (data) => {
    if (data.length < 2)
        throw RangeError('Could not decode int16BE');
    if (data instanceof BufferList_1.default) {
        return data.readUInt16BE(0);
    }
    return new DataView(data.buffer, data.byteOffset, data.byteLength).getUint16(0, false);
};
exports.uint16BEDecode = uint16BEDecode;
exports.uint16BEDecode.bytes = 2;
// Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)
function encode0(message) {
    return (0, concat_1.concat)([message.ne, message.ciphertext], message.ne.length + message.ciphertext.length);
}
exports.encode0 = encode0;
function encode1(message) {
    return (0, concat_1.concat)([message.ne, message.ns, message.ciphertext], message.ne.length + message.ns.length + message.ciphertext.length);
}
exports.encode1 = encode1;
function encode2(message) {
    return (0, concat_1.concat)([message.ns, message.ciphertext], message.ns.length + message.ciphertext.length);
}
exports.encode2 = encode2;
function decode0(input) {
    if (input.length < 32) {
        throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.');
    }
    return {
        ne: input.slice(0, 32),
        ciphertext: input.slice(32, input.length),
        ns: new Uint8Array(0)
    };
}
exports.decode0 = decode0;
function decode1(input) {
    if (input.length < 80) {
        throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.');
    }
    return {
        ne: input.slice(0, 32),
        ns: input.slice(32, 80),
        ciphertext: input.slice(80, input.length)
    };
}
exports.decode1 = decode1;
function decode2(input) {
    if (input.length < 48) {
        throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.');
    }
    return {
        ne: new Uint8Array(0),
        ns: input.slice(0, 48),
        ciphertext: input.slice(48, input.length)
    };
}
exports.decode2 = decode2;
//# sourceMappingURL=encoder.js.map