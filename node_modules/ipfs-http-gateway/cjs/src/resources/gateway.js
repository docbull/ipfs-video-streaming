'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debug = require('debug');
var fromString = require('uint8arrays/from-string');
var Boom = require('@hapi/boom');
var Ammo = require('@hapi/ammo');
var last = require('it-last');
var cid = require('multiformats/cid');
var base32 = require('multiformats/bases/base32');
var ipfsHttpResponse = require('ipfs-http-response');
var isIPFS = require('is-ipfs');
var toStream = require('it-to-stream');
var path = require('../utils/path.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var Ammo__default = /*#__PURE__*/_interopDefaultLegacy(Ammo);
var last__default = /*#__PURE__*/_interopDefaultLegacy(last);
var isIPFS__default = /*#__PURE__*/_interopDefaultLegacy(isIPFS);
var toStream__default = /*#__PURE__*/_interopDefaultLegacy(toStream);

const {detectContentType} = ipfsHttpResponse.utils;
const log = Object.assign(debug__default["default"]('ipfs:http-gateway'), { error: debug__default["default"]('ipfs:http-gateway:error') });
const Gateway = {
  async handler(request, h) {
    const {ipfs} = request.server.app;
    const path$1 = request.path;
    let ipfsPath = path$1;
    if (path$1.startsWith('/ipns/')) {
      ipfsPath = await last__default["default"](ipfs.name.resolve(path$1, { recursive: true })) || path$1;
    }
    ipfsPath = decodeURI(ipfsPath);
    let directory = false;
    let data;
    try {
      data = await ipfsHttpResponse.resolver.cid(ipfs, ipfsPath);
    } catch (err) {
      const errorToString = err.toString();
      log.error('err: ', errorToString, ' fileName: ', err.fileName);
      switch (true) {
      case errorToString === 'Error: This dag node is a directory':
        directory = true;
        data = await ipfsHttpResponse.resolver.directory(ipfs, ipfsPath, err.cid);
        if (typeof data === 'string') {
          if (!path$1.endsWith('/')) {
            return h.redirect(`${ path$1 }/`).permanent(true);
          }
          return h.response(data);
        }
        ipfsPath = path.joinURLParts(ipfsPath, data[0].Name);
        data = await ipfsHttpResponse.resolver.cid(ipfs, ipfsPath);
        break;
      case errorToString.startsWith('Error: no link named'):
        throw Boom__default["default"].boomify(err, { statusCode: 404 });
      case errorToString.startsWith('Error: multihash length inconsistent'):
      case errorToString.startsWith('Error: Non-base58 character'):
      case errorToString.startsWith('Error: invalid character'):
        throw Boom__default["default"].boomify(err, { statusCode: 400 });
      default:
        log.error(err);
        throw err;
      }
    }
    if (!directory && path$1.endsWith('/')) {
      return h.redirect(path.removeTrailingSlash(path$1)).permanent(true);
    }
    if (directory && !path$1.endsWith('/')) {
      return h.redirect(`${ path$1 }/`).permanent(true);
    }
    if (request.headers['service-worker'] === 'script') {
      if (path$1.match(/^\/ip[nf]s\/[^/]+$/))
        throw Boom__default["default"].badRequest('navigator.serviceWorker: registration is not allowed for this scope');
    }
    const etag = `"${ data.cid }"`;
    const cachedEtag = request.headers['if-none-match'];
    if (cachedEtag === etag || cachedEtag === `W/${ etag }`) {
      return h.response().code(304);
    }
    if (path$1.startsWith('/ipfs/') && request.headers['if-modified-since']) {
      return h.response().code(304);
    }
    const {size} = await ipfs.files.stat(`/ipfs/${ data.cid }`);
    const catOptions = {};
    let rangeResponse = false;
    if (request.headers.range) {
      if (!request.headers['if-range'] || request.headers['if-range'] === etag) {
        const ranges = Ammo__default["default"].header(request.headers.range, size);
        if (!ranges) {
          const error = Boom__default["default"].rangeNotSatisfiable();
          error.output.headers['content-range'] = `bytes */${ size }`;
          throw error;
        }
        if (ranges.length === 1) {
          rangeResponse = true;
          const range = ranges[0];
          catOptions.offset = range.from;
          catOptions.length = range.to - range.from + 1;
        }
      }
    }
    const {source, contentType} = await detectContentType(ipfsPath, ipfs.cat(data.cid, catOptions));
    const responseStream = toStream__default["default"].readable(async function* () {
      for await (const chunk of source) {
        yield chunk.slice();
      }
    }());
    const res = h.response(responseStream).code(rangeResponse ? 206 : 200);
    res.header('etag', etag);
    if (path$1.startsWith('/ipfs/')) {
      res.header('Cache-Control', 'public, max-age=29030400, immutable');
    }
    log('HTTP path ', path$1);
    log('IPFS path ', ipfsPath);
    log('content-type ', contentType);
    if (contentType) {
      log('writing content-type header');
      res.header('Content-Type', contentType);
    }
    if (rangeResponse) {
      const from = catOptions.offset;
      const to = catOptions.offset + catOptions.length - 1;
      res.header('Content-Range', `bytes ${ from }-${ to }/${ size }`);
      res.header('Content-Length', `${ catOptions.length }`);
    } else {
      res.header('Accept-Ranges', 'bytes');
      res.header('Content-Length', `${ size }`);
    }
    if (request.query.filename) {
      res.header('Content-Disposition', `inline; filename*=UTF-8''${ encodeURIComponent(request.query.filename) }`);
    }
    return res;
  },
  afterHandler(request, h) {
    const {response} = request;
    if (Boom__default["default"].isBoom(response)) {
      return h.continue;
    }
    if (response.statusCode === 200 || response.statusCode === 206) {
      const path = request.path;
      response.header('X-Ipfs-Path', path);
      if (path.startsWith('/ipfs/')) {
        response.header('Last-Modified', 'Thu, 01 Jan 1970 00:00:01 GMT');
        const rootCid = path.split('/')[2];
        const ipfsOrigin = cid.CID.parse(rootCid).toV1().toString(base32.base32);
        response.header('Suborigin', `ipfs000${ ipfsOrigin }`);
      } else if (path.startsWith('/ipns/')) {
        const root = path.split('/')[2];
        const ipnsOrigin = isIPFS__default["default"].cid(root) ? cid.CID.parse(root).toV1().toString(base32.base32) : base32.base32.encode(fromString.fromString(root));
        response.header('Suborigin', `ipns000${ ipnsOrigin }`);
      }
    }
    return h.continue;
  }
};

exports.Gateway = Gateway;
