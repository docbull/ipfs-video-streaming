import debug from 'debug';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import Boom from '@hapi/boom';
import Ammo from '@hapi/ammo';
import last from 'it-last';
import { CID } from 'multiformats/cid';
import { base32 } from 'multiformats/bases/base32';
import {
  resolver,
  utils
} from 'ipfs-http-response';
import isIPFS from 'is-ipfs';
import toStream from 'it-to-stream';
import * as PathUtils from '../utils/path.js';
const {detectContentType} = utils;
const log = Object.assign(debug('ipfs:http-gateway'), { error: debug('ipfs:http-gateway:error') });
export const Gateway = {
  async handler(request, h) {
    const {ipfs} = request.server.app;
    const path = request.path;
    let ipfsPath = path;
    if (path.startsWith('/ipns/')) {
      ipfsPath = await last(ipfs.name.resolve(path, { recursive: true })) || path;
    }
    ipfsPath = decodeURI(ipfsPath);
    let directory = false;
    let data;
    try {
      data = await resolver.cid(ipfs, ipfsPath);
    } catch (err) {
      const errorToString = err.toString();
      log.error('err: ', errorToString, ' fileName: ', err.fileName);
      switch (true) {
      case errorToString === 'Error: This dag node is a directory':
        directory = true;
        data = await resolver.directory(ipfs, ipfsPath, err.cid);
        if (typeof data === 'string') {
          if (!path.endsWith('/')) {
            return h.redirect(`${ path }/`).permanent(true);
          }
          return h.response(data);
        }
        ipfsPath = PathUtils.joinURLParts(ipfsPath, data[0].Name);
        data = await resolver.cid(ipfs, ipfsPath);
        break;
      case errorToString.startsWith('Error: no link named'):
        throw Boom.boomify(err, { statusCode: 404 });
      case errorToString.startsWith('Error: multihash length inconsistent'):
      case errorToString.startsWith('Error: Non-base58 character'):
      case errorToString.startsWith('Error: invalid character'):
        throw Boom.boomify(err, { statusCode: 400 });
      default:
        log.error(err);
        throw err;
      }
    }
    if (!directory && path.endsWith('/')) {
      return h.redirect(PathUtils.removeTrailingSlash(path)).permanent(true);
    }
    if (directory && !path.endsWith('/')) {
      return h.redirect(`${ path }/`).permanent(true);
    }
    if (request.headers['service-worker'] === 'script') {
      if (path.match(/^\/ip[nf]s\/[^/]+$/))
        throw Boom.badRequest('navigator.serviceWorker: registration is not allowed for this scope');
    }
    const etag = `"${ data.cid }"`;
    const cachedEtag = request.headers['if-none-match'];
    if (cachedEtag === etag || cachedEtag === `W/${ etag }`) {
      return h.response().code(304);
    }
    if (path.startsWith('/ipfs/') && request.headers['if-modified-since']) {
      return h.response().code(304);
    }
    const {size} = await ipfs.files.stat(`/ipfs/${ data.cid }`);
    const catOptions = {};
    let rangeResponse = false;
    if (request.headers.range) {
      if (!request.headers['if-range'] || request.headers['if-range'] === etag) {
        const ranges = Ammo.header(request.headers.range, size);
        if (!ranges) {
          const error = Boom.rangeNotSatisfiable();
          error.output.headers['content-range'] = `bytes */${ size }`;
          throw error;
        }
        if (ranges.length === 1) {
          rangeResponse = true;
          const range = ranges[0];
          catOptions.offset = range.from;
          catOptions.length = range.to - range.from + 1;
        }
      }
    }
    const {source, contentType} = await detectContentType(ipfsPath, ipfs.cat(data.cid, catOptions));
    const responseStream = toStream.readable(async function* () {
      for await (const chunk of source) {
        yield chunk.slice();
      }
    }());
    const res = h.response(responseStream).code(rangeResponse ? 206 : 200);
    res.header('etag', etag);
    if (path.startsWith('/ipfs/')) {
      res.header('Cache-Control', 'public, max-age=29030400, immutable');
    }
    log('HTTP path ', path);
    log('IPFS path ', ipfsPath);
    log('content-type ', contentType);
    if (contentType) {
      log('writing content-type header');
      res.header('Content-Type', contentType);
    }
    if (rangeResponse) {
      const from = catOptions.offset;
      const to = catOptions.offset + catOptions.length - 1;
      res.header('Content-Range', `bytes ${ from }-${ to }/${ size }`);
      res.header('Content-Length', `${ catOptions.length }`);
    } else {
      res.header('Accept-Ranges', 'bytes');
      res.header('Content-Length', `${ size }`);
    }
    if (request.query.filename) {
      res.header('Content-Disposition', `inline; filename*=UTF-8''${ encodeURIComponent(request.query.filename) }`);
    }
    return res;
  },
  afterHandler(request, h) {
    const {response} = request;
    if (Boom.isBoom(response)) {
      return h.continue;
    }
    if (response.statusCode === 200 || response.statusCode === 206) {
      const path = request.path;
      response.header('X-Ipfs-Path', path);
      if (path.startsWith('/ipfs/')) {
        response.header('Last-Modified', 'Thu, 01 Jan 1970 00:00:01 GMT');
        const rootCid = path.split('/')[2];
        const ipfsOrigin = CID.parse(rootCid).toV1().toString(base32);
        response.header('Suborigin', `ipfs000${ ipfsOrigin }`);
      } else if (path.startsWith('/ipns/')) {
        const root = path.split('/')[2];
        const ipnsOrigin = isIPFS.cid(root) ? CID.parse(root).toV1().toString(base32) : base32.encode(uint8ArrayFromString(root));
        response.header('Suborigin', `ipns000${ ipnsOrigin }`);
      }
    }
    return h.continue;
  }
};