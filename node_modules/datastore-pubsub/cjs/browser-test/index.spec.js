'use strict';

var chai_js = require('aegir/utils/chai.js');
var sinon = require('sinon');
var errcode = require('err-code');
var isNode = require('detect-node');
var toString = require('uint8arrays/to-string');
var fromString = require('uint8arrays/from-string');
var index = require('../src/index.js');
var interfaceDatastore = require('interface-datastore');
var datastoreCore = require('datastore-core');
var utils = require('./utils.js');
var libp2pRecord = require('libp2p-record');
var utils$1 = require('../src/utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var sinon__default = /*#__PURE__*/_interopDefaultLegacy(sinon);
var errcode__default = /*#__PURE__*/_interopDefaultLegacy(errcode);
var isNode__default = /*#__PURE__*/_interopDefaultLegacy(isNode);

const smoothValidator = {
  validate: () => {
    return Promise.resolve();
  },
  select: () => {
    return 0;
  }
};
describe('datastore-pubsub', function () {
  this.timeout(60 * 1000);
  if (!isNode__default["default"])
    return;
  let pubsubA;
  let datastoreA;
  let peerIdA;
  const registrarRecordA = {};
  let pubsubB;
  let datastoreB;
  let peerIdB;
  const registrarRecordB = {};
  before(async () => {
    [pubsubA, pubsubB] = await Promise.all([
      utils.createPubsubNode(registrarRecordA),
      utils.createPubsubNode(registrarRecordB)
    ]);
    peerIdA = pubsubA.peerId;
    peerIdB = pubsubB.peerId;
    await utils.connectPubsubNodes({
      router: pubsubA,
      registrar: registrarRecordA
    }, {
      router: pubsubB,
      registrar: registrarRecordB
    });
    datastoreA = new datastoreCore.MemoryDatastore();
    datastoreB = new datastoreCore.MemoryDatastore();
  });
  const value = 'value';
  let testCounter = 0;
  let keyRef = '';
  let key;
  let record;
  let serializedRecord;
  beforeEach(() => {
    keyRef = `key${ testCounter }`;
    key = new interfaceDatastore.Key(keyRef).uint8Array();
    record = new libp2pRecord.Record(key, fromString.fromString(value));
    serializedRecord = record.serialize();
  });
  afterEach(() => {
    ++testCounter;
  });
  after(() => {
    return Promise.all([
      pubsubA.stop(),
      pubsubB.stop()
    ]);
  });
  it('should subscribe the topic, but receive error as no entry is stored locally', async () => {
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const subsTopic = utils$1.keyToTopic(`/${ keyRef }`);
    let subscribers = await pubsubA.getTopics();
    chai_js.expect(subscribers).to.exist();
    chai_js.expect(subscribers).to.not.include(subsTopic);
    await chai_js.expect(dsPubsubA.get(key)).to.eventually.be.rejected().with.property('code', 'ERR_NOT_FOUND');
    subscribers = await pubsubA.getTopics();
    chai_js.expect(subscribers).to.exist();
    chai_js.expect(subscribers).to.include(subsTopic);
  });
  it('should put correctly to node A and node B should not receive it without subscribing', async () => {
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, smoothValidator);
    const subsTopic = utils$1.keyToTopic(`/${ keyRef }`);
    const res = await pubsubB.getTopics();
    chai_js.expect(res).to.exist();
    chai_js.expect(res).to.not.include(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await dsPubsubB.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    });
  });
  it('should validate if record content is the same', async () => {
    const customValidator = {
      validate: data => {
        const receivedRecord = libp2pRecord.Record.deserialize(data);
        chai_js.expect(receivedRecord.value.toString()).to.equal(value);
        if (receivedRecord.value.toString() === value) {
          return Promise.resolve();
        }
        return Promise.reject(new Error('invalid record'));
      },
      select: () => {
        return 0;
      }
    };
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    const subsTopic = utils$1.keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    await chai_js.expect(dsPubsubB.get(key)).to.eventually.be.rejected().with.property('code', 'ERR_NOT_FOUND');
    await utils.waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await utils.waitFor(() => receivedMessage === true);
    const record = await dsPubsubB.get(key);
    chai_js.expect(record).to.be.ok();
  });
  it('should put correctly to daemon A and daemon B should receive it as it tried to get it first and subscribed it', async () => {
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, smoothValidator);
    const subsTopic = utils$1.keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    const res = await pubsubB.getTopics();
    chai_js.expect(res).to.exist();
    chai_js.expect(res).to.not.include(subsTopic);
    await dsPubsubB.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await utils.waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await utils.waitFor(() => receivedMessage === true);
    const result = await dsPubsubB.get(key);
    chai_js.expect(result).to.exist();
    const receivedRecord = libp2pRecord.Record.deserialize(result);
    chai_js.expect(receivedRecord.value.toString()).to.equal(value);
  });
  it('should fail to create the PubsubDatastore if no validator is provided', () => {
    let dsPubsubB;
    try {
      dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB);
    } catch (err) {
      chai_js.expect(err.code).to.equal('ERR_INVALID_PARAMETERS');
    }
    chai_js.expect(dsPubsubB).to.equal(undefined);
  });
  it('should fail to create the PubsubDatastore if no validate function is provided', () => {
    const customValidator = {
      validate: undefined,
      select: () => {
        return 0;
      }
    };
    let dsPubsubB;
    try {
      dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    } catch (err) {
      chai_js.expect(err.code).to.equal('ERR_INVALID_PARAMETERS');
    }
    chai_js.expect(dsPubsubB).to.equal(undefined);
  });
  it('should fail to create the PubsubDatastore if no select function is provided', () => {
    const customValidator = {
      validate: () => {
        return true;
      },
      select: undefined
    };
    let dsPubsubB;
    try {
      dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    } catch (err) {
      chai_js.expect(err.code).to.equal('ERR_INVALID_PARAMETERS');
    }
    chai_js.expect(dsPubsubB).to.equal(undefined);
  });
  it('should fail if it fails getTopics to validate the record', async () => {
    const customValidator = {
      validate: () => {
        throw new Error();
      },
      select: () => {
        return 0;
      }
    };
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    const subsTopic = utils$1.keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    await dsPubsubB.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await utils.waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    await pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await utils.waitFor(() => receivedMessage === true);
    try {
      await dsPubsubB.get(key);
      chai_js.expect.fail('Should have disguarded invalid message');
    } catch (err) {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    }
  });
  it('should get the second record if the selector selects it as the newest one', async () => {
    const customValidator = {
      validate: () => {
        return Promise.resolve();
      },
      select: () => {
        return 1;
      }
    };
    const newValue = 'new value';
    const record = new libp2pRecord.Record(key, fromString.fromString(newValue));
    const newSerializedRecord = record.serialize();
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    const subsTopic = utils$1.keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    await dsPubsubB.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await utils.waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    await pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await utils.waitFor(() => receivedMessage === true);
    await dsPubsubA.put(key, newSerializedRecord);
    await utils.waitFor(() => receivedMessage === true);
    const result = await dsPubsubB.get(key);
    const receivedRecord = libp2pRecord.Record.deserialize(result);
    chai_js.expect(receivedRecord.value.toString()).to.not.equal(newValue);
  });
  it('should get the new record if the selector selects it as the newest one', async () => {
    const customValidator = {
      validate: () => {
        return Promise.resolve();
      },
      select: () => {
        return 0;
      }
    };
    const newValue = 'new value';
    const record = new libp2pRecord.Record(key, fromString.fromString(newValue));
    const newSerializedRecord = record.serialize();
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    const subsTopic = utils$1.keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    await dsPubsubB.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await utils.waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    await pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await utils.waitFor(() => receivedMessage === true);
    receivedMessage = false;
    await dsPubsubA.put(key, newSerializedRecord);
    await utils.waitFor(() => receivedMessage === true);
    const result = await dsPubsubB.get(key);
    const receivedRecord = libp2pRecord.Record.deserialize(result);
    chai_js.expect(receivedRecord.value.toString()).to.equal(newValue);
  });
  it('should subscribe the topic and after a message being received, discard it using the subscriptionKeyFn', async () => {
    const subscriptionKeyFn = key => {
      chai_js.expect(toString.toString(key)).to.equal(`/${ keyRef }`);
      throw new Error('DISCARD MESSAGE');
    };
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, smoothValidator, subscriptionKeyFn);
    const subsTopic = utils$1.keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    const res = await pubsubB.getTopics();
    chai_js.expect(res).to.not.include(subsTopic);
    await dsPubsubB.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await utils.waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    await pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await utils.waitFor(() => receivedMessage === true);
    try {
      await dsPubsubB.get(key);
      chai_js.expect.fail('Should not have stored message');
    } catch (err) {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    }
  });
  it('should subscribe the topic and after a message being received, change its key using subscriptionKeyFn', async () => {
    const subscriptionKeyFn = key => {
      chai_js.expect(toString.toString(key)).to.equal(`/${ keyRef }`);
      return Promise.resolve(utils$1.topicToKey(`${ utils$1.keyToTopic(key) }new`));
    };
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new index.PubsubDatastore(pubsubB, datastoreB, peerIdB, smoothValidator, subscriptionKeyFn);
    const subsTopic = utils$1.keyToTopic(`/${ keyRef }`);
    const keyNew = utils$1.topicToKey(`${ utils$1.keyToTopic(key) }new`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    const res = await pubsubB.getTopics();
    chai_js.expect(res).to.not.include(subsTopic);
    await dsPubsubB.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await utils.waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await utils.waitFor(() => receivedMessage === true);
    const result = await dsPubsubB.get(keyNew);
    const receivedRecord = libp2pRecord.Record.deserialize(result);
    chai_js.expect(toString.toString(receivedRecord.value)).to.equal(value);
  });
  it('should subscribe a topic only once', async () => {
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    sinon__default["default"].spy(pubsubA, 'subscribe');
    await dsPubsubA.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await dsPubsubA.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    chai_js.expect(pubsubA.subscribe.calledOnce).to.equal(true);
  });
  it('should handle a unexpected error properly when getting from the datastore', async () => {
    const dsPubsubA = new index.PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const stub = sinon__default["default"].stub(dsPubsubA._datastore, 'get').throws(errcode__default["default"](new Error('Wut'), 'RANDOM_ERR'));
    await dsPubsubA.get(key).then(() => chai_js.expect.fail('Should have failed to fetch key'), err => {
      chai_js.expect(err.code).to.equal('ERR_UNEXPECTED_ERROR_GETTING_RECORD');
    }).finally(() => {
      stub.restore();
    });
  });
});
