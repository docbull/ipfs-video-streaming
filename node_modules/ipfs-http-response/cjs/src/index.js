'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var toStream = require('it-to-stream');
var concat = require('it-concat');
var toBuffer = require('it-buffer');
var debug = require('debug');
var resolver$1 = require('./resolver.js');
var path = require('./utils/path.js');
var contentType = require('./utils/content-type.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var toStream__default = /*#__PURE__*/_interopDefaultLegacy(toStream);
var concat__default = /*#__PURE__*/_interopDefaultLegacy(concat);
var toBuffer__default = /*#__PURE__*/_interopDefaultLegacy(toBuffer);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = debug__default["default"]('ipfs:http:response');
const getHeader = (status = 200, statusText = 'OK', headers = {}) => ({
  status,
  statusText,
  headers
});
const handleResolveError = async (node, path$1, error) => {
  const errorString = error.toString();
  if (errorString.includes('dag node is a directory')) {
    try {
      const content = await resolver$1.directory(node, path$1, error.cid);
      if (typeof content === 'string') {
        return new Response(content, getHeader(200, 'OK', { 'Content-Type': 'text/html' }));
      }
      return Response.redirect(path.joinURLParts(path$1, content[0].Name));
    } catch (error) {
      log(error);
      return new Response(errorString, getHeader(500, error.toString()));
    }
  }
  if (errorString.startsWith('Error: no link named')) {
    return new Response(errorString, getHeader(404, errorString));
  }
  if (errorString.startsWith('Error: multihash length inconsistent') || errorString.startsWith('Error: Non-base58 character')) {
    return new Response(errorString, getHeader(400, errorString));
  }
  return new Response(errorString, getHeader(500, errorString));
};
async function getResponse(ipfsNode, ipfsPath) {
  if (ipfsPath.endsWith('/')) {
    return Response.redirect(path.removeTrailingSlash(ipfsPath));
  }
  try {
    const resolvedData = await resolver$1.cid(ipfsNode, ipfsPath);
    const {source, contentType: contentType$1} = await contentType.detectContentType(ipfsPath, ipfsNode.cat(resolvedData.cid));
    if (typeof Blob === 'undefined') {
      const responseStream = toStream__default["default"].readable(toBuffer__default["default"](source));
      return contentType$1 ? new Response(responseStream, getHeader(200, 'OK', { 'Content-Type': contentType$1 })) : new Response(responseStream, getHeader());
    }
    try {
      const data = await concat__default["default"](source);
      const blob = new Blob([data.slice()]);
      return contentType$1 ? new Response(blob, getHeader(200, 'OK', { 'Content-Type': contentType$1 })) : new Response(blob, getHeader());
    } catch (err) {
      return new Response(err.toString(), getHeader(500, 'Error fetching the file'));
    }
  } catch (error) {
    log(error);
    return handleResolveError(ipfsNode, ipfsPath, error);
  }
}
const resolver = { ...resolver$1 };
const utils = { detectContentType: contentType.detectContentType };

exports.getResponse = getResponse;
exports.resolver = resolver;
exports.utils = utils;
