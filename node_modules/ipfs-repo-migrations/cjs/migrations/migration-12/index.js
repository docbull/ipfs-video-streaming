'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var $protobuf = require('protobufjs/minimal.js');
var key = require('interface-datastore/key');
var protoBook = require('./pb/proto-book.js');
var addressBook = require('./pb/address-book.js');
var peer = require('./pb/peer.js');
var envelope = require('./pb/envelope.js');
var peerRecord = require('./pb/peer-record.js');
var multiaddr = require('multiaddr');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var $protobuf__default = /*#__PURE__*/_interopDefaultLegacy($protobuf);

$protobuf__default["default"].util.Long = undefined;
$protobuf__default["default"].configure();
async function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {
}) {
  onProgress(0, 'Storing each peerstore key under a single datastore key');
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const {key, value} of backends.datastore.query({ prefix: '/peers' })) {
    keys.push(key);
    const keyStr = key.toString();
    const [_, prefix, type, peerId, metadataKey] = keyStr.split('/');
    if (prefix !== 'peers') {
      continue;
    }
    if (![
        'protos',
        'addrs',
        'metadata',
        'keys'
      ].includes(type)) {
      continue;
    }
    if (!peerId) {
      continue;
    }
    peers[peerId] = peers[peerId] || {
      addresses: [],
      protocols: [],
      metadata: []
    };
    if (type === 'protos') {
      const protos = protoBook.Protocols.decode(value);
      peers[peerId].protocols = protos.protocols.sort();
    } else if (type === 'addrs') {
      const addrs = addressBook.Addresses.decode(value);
      peers[peerId].addresses = addrs.addrs.sort((a, b) => {
        return new multiaddr.Multiaddr(a.multiaddr).toString().localeCompare(new multiaddr.Multiaddr(b.multiaddr).toString());
      });
      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {
        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;
      }
    } else if (type === 'metadata') {
      peers[peerId].metadata.push({
        key: metadataKey,
        value
      });
    } else if (type === 'keys') {
      peers[peerId].pubKey = value;
    }
  }
  onProgress(33, 'Read peer data from store');
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, 'Removed existing peer data from store');
  for (const peerId of Object.keys(peers)) {
    const peer$1 = peers[peerId];
    peer$1.metadata = peer$1.metadata.sort((a, b) => a.key.localeCompare(b.key));
    const data = peer.Peer.encode(peer$1).finish();
    await backends.datastore.put(new key.Key(`/peers/${ peerId }`), data);
  }
  await backends.datastore.close();
  onProgress(100, 'Stored each peerstore key under a single datastore key');
}
async function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {
}) {
  onProgress(0, 'Storing each peerstore key under a multiple datastore keys');
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const {key, value} of backends.datastore.query({ prefix: '/peers' })) {
    keys.push(key);
    const keyStr = key.toString();
    const [_, _prefix, peerId] = keyStr.split('/');
    peers[peerId] = peer.Peer.decode(value);
  }
  onProgress(33, 'Read peer data from store');
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, 'Removed existing peer data from store');
  for (const [peerId, peer] of Object.entries(peers)) {
    if (peer.protocols && peer.protocols.length > 0) {
      await backends.datastore.put(new key.Key(`/peers/protos/${ peerId }`), protoBook.Protocols.encode({ protocols: peer.protocols }).finish());
    }
    if (peer.addresses && peer.addresses.length > 0) {
      const peerRecordEnvelope = peer.peerRecordEnvelope;
      let certifiedRecord;
      if (peerRecordEnvelope) {
        const envelope$1 = envelope.Envelope.decode(peerRecordEnvelope);
        const record = peerRecord.PeerRecord.decode(envelope$1.payload);
        certifiedRecord = {
          raw: peerRecordEnvelope,
          seq: record.seq
        };
      }
      await backends.datastore.put(new key.Key(`/peers/addrs/${ peerId }`), addressBook.Addresses.encode({
        addrs: peer.addresses,
        certifiedRecord
      }).finish());
    }
    if (peer.metadata && peer.metadata.length > 0) {
      for (const {key: key$1, value} of peer.metadata) {
        await backends.datastore.put(new key.Key(`/peers/metadata/${ peerId }/${ key$1 }`), value);
      }
    }
    if (peer.pubKey) {
      await backends.datastore.put(new key.Key(`/peers/keys/${ peerId }`), peer.pubKey);
    }
  }
  await backends.datastore.close();
  onProgress(100, 'Stored each peerstore key under multiple datastore keys');
}
const migration = {
  version: 12,
  description: 'Store each peerstore peer under a single datastore key',
  migrate: storePeerUnderSingleDatastoreKey,
  revert: storePeerUnderMultipleDatastoreKeys
};

exports.migration = migration;
