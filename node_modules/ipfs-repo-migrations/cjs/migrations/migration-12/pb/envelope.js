'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var $protobuf = require('protobufjs/minimal.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var $protobuf__default = /*#__PURE__*/_interopDefaultLegacy($protobuf);

const $Reader = $protobuf__default["default"].Reader, $Writer = $protobuf__default["default"].Writer, $util = $protobuf__default["default"].util;
const $root = $protobuf__default["default"].roots['default'] || ($protobuf__default["default"].roots['default'] = {});
const Envelope = $root.Envelope = (() => {
  function Envelope(p) {
    if (p)
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
  }
  Envelope.prototype.publicKey = $util.newBuffer([]);
  Envelope.prototype.payloadType = $util.newBuffer([]);
  Envelope.prototype.payload = $util.newBuffer([]);
  Envelope.prototype.signature = $util.newBuffer([]);
  Envelope.encode = function encode(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, 'publicKey'))
      w.uint32(10).bytes(m.publicKey);
    if (m.payloadType != null && Object.hasOwnProperty.call(m, 'payloadType'))
      w.uint32(18).bytes(m.payloadType);
    if (m.payload != null && Object.hasOwnProperty.call(m, 'payload'))
      w.uint32(26).bytes(m.payload);
    if (m.signature != null && Object.hasOwnProperty.call(m, 'signature'))
      w.uint32(42).bytes(m.signature);
    return w;
  };
  Envelope.decode = function decode(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l, m = new $root.Envelope();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
      case 1:
        m.publicKey = r.bytes();
        break;
      case 2:
        m.payloadType = r.bytes();
        break;
      case 3:
        m.payload = r.bytes();
        break;
      case 5:
        m.signature = r.bytes();
        break;
      default:
        r.skipType(t & 7);
        break;
      }
    }
    return m;
  };
  Envelope.fromObject = function fromObject(d) {
    if (d instanceof $root.Envelope)
      return d;
    var m = new $root.Envelope();
    if (d.publicKey != null) {
      if (typeof d.publicKey === 'string')
        $util.base64.decode(d.publicKey, m.publicKey = $util.newBuffer($util.base64.length(d.publicKey)), 0);
      else if (d.publicKey.length)
        m.publicKey = d.publicKey;
    }
    if (d.payloadType != null) {
      if (typeof d.payloadType === 'string')
        $util.base64.decode(d.payloadType, m.payloadType = $util.newBuffer($util.base64.length(d.payloadType)), 0);
      else if (d.payloadType.length)
        m.payloadType = d.payloadType;
    }
    if (d.payload != null) {
      if (typeof d.payload === 'string')
        $util.base64.decode(d.payload, m.payload = $util.newBuffer($util.base64.length(d.payload)), 0);
      else if (d.payload.length)
        m.payload = d.payload;
    }
    if (d.signature != null) {
      if (typeof d.signature === 'string')
        $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);
      else if (d.signature.length)
        m.signature = d.signature;
    }
    return m;
  };
  Envelope.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.defaults) {
      if (o.bytes === String)
        d.publicKey = '';
      else {
        d.publicKey = [];
        if (o.bytes !== Array)
          d.publicKey = $util.newBuffer(d.publicKey);
      }
      if (o.bytes === String)
        d.payloadType = '';
      else {
        d.payloadType = [];
        if (o.bytes !== Array)
          d.payloadType = $util.newBuffer(d.payloadType);
      }
      if (o.bytes === String)
        d.payload = '';
      else {
        d.payload = [];
        if (o.bytes !== Array)
          d.payload = $util.newBuffer(d.payload);
      }
      if (o.bytes === String)
        d.signature = '';
      else {
        d.signature = [];
        if (o.bytes !== Array)
          d.signature = $util.newBuffer(d.signature);
      }
    }
    if (m.publicKey != null && m.hasOwnProperty('publicKey')) {
      d.publicKey = o.bytes === String ? $util.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }
    if (m.payloadType != null && m.hasOwnProperty('payloadType')) {
      d.payloadType = o.bytes === String ? $util.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
    }
    if (m.payload != null && m.hasOwnProperty('payload')) {
      d.payload = o.bytes === String ? $util.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
    }
    if (m.signature != null && m.hasOwnProperty('signature')) {
      d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }
    return d;
  };
  Envelope.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf__default["default"].util.toJSONOptions);
  };
  return Envelope;
})();

exports.Envelope = Envelope;
exports["default"] = $root;
