'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var grpc = require('@grpc/grpc-js');
var first = require('it-first');
var debug = require('debug');
var webSocketServer = require('./utils/web-socket-server.js');
var loadServices = require('./utils/load-services.js');
var add = require('./endpoints/add.js');
var id = require('./endpoints/id.js');
var ls = require('./endpoints/mfs/ls.js');
var write = require('./endpoints/mfs/write.js');
var subscribe = require('./endpoints/pubsub/subscribe.js');
var unsubscribe = require('./endpoints/pubsub/unsubscribe.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var grpc__default = /*#__PURE__*/_interopDefaultLegacy(grpc);
var first__default = /*#__PURE__*/_interopDefaultLegacy(first);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = debug__default["default"]('ipfs:grpc-server');
const {Root, MFS, PubSub} = loadServices.loadServices();
async function createServer(ipfs, options = {}) {
  options = options || {};
  const server = new grpc__default["default"].Server();
  server.addService(Root, {
    add: add.grpcAdd(ipfs, options),
    id: id.grpcId(ipfs, options)
  });
  server.addService(MFS, {
    ls: ls.grpcMfsLs(ipfs, options),
    write: write.grpcMfsWrite(ipfs, options)
  });
  server.addService(PubSub, {
    subscribe: subscribe.grpcPubsubSubscribe(ipfs, options),
    unsubscribe: unsubscribe.grpcPubsubUnsubscribe(ipfs, options)
  });
  const socket = options.socket || await webSocketServer.webSocketServer(ipfs, options);
  socket.on('error', error => log(error));
  socket.on('data', async ({path, metadata, channel}) => {
    const handler = server.handlers.get(path);
    if (!handler) {
      channel.end(new Error(`Request path ${ path } unimplemented`));
      return;
    }
    channel.handler = handler;
    switch (handler.type) {
    case 'bidi':
      handler.func(channel.source, channel.sink, metadata).catch(err => {
        channel.end(err);
      });
      channel.sendMetadata({});
      for await (const output of channel.sink) {
        channel.sendMessage(output);
      }
      channel.end();
      break;
    case 'unary':
      handler.func(await first__default["default"](channel.source), metadata, (err, value, metadata, flags) => {
        if (err) {
          return channel.end(err);
        }
        channel.sendMetadata(metadata || {});
        if (value) {
          channel.sendMessage(value);
        }
        channel.end();
      });
      break;
    case 'clientStream':
      handler.func(channel.source, metadata, (err, value, metadata, flags) => {
        if (err) {
          return channel.end(err);
        }
        channel.sendMetadata(metadata || {});
        if (value) {
          channel.sendMessage(value);
        }
        channel.end();
      });
      break;
    case 'serverStream':
      handler.func(await first__default["default"](channel.source), channel.sink, metadata).catch(err => {
        channel.end(err);
      });
      channel.sendMetadata({});
      for await (const output of channel.sink) {
        channel.sendMessage(output);
      }
      channel.end();
      break;
    default:
      log(`Invalid handler type ${ handler.type }`);
    }
  });
  return socket;
}

exports.createServer = createServer;
