'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var pushable = require('it-pushable');
var changeCase = require('change-case');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var pushable__default = /*#__PURE__*/_interopDefaultLegacy(pushable);

const WebsocketSignal = {
  START_SEND: 0,
  FINISH_SEND: 1
};
const HEADER_SIZE = 5;
const TRAILER_BYTES = 128;
const objectToHeaders = object => {
  const output = {};
  Object.keys(object).forEach(key => {
    if (typeof object[key] === 'function') {
      return;
    }
    output[changeCase.paramCase(key)] = object[key];
  });
  return Buffer.from(Object.entries(output).filter(([, value]) => value != null).map(([key, value]) => `${ key }: ${ JSON.stringify(value) }`).join('\r\n'));
};
class WebSocketMessageChannel {
  constructor(ws) {
    this._ws = ws;
    this.handler = {
      deserialize: buf => ({}),
      serialize: message => Buffer.from([])
    };
    this.source = pushable__default["default"]();
    this.sink = pushable__default["default"]();
    ws.on('message', buf => {
      if (!(buf instanceof Uint8Array)) {
        this.source.end(new Error(`Incorrect message type received - expected Uint8Array, got ${ typeof buf }`));
        this.sink.end();
        ws.terminate();
        return;
      }
      const flag = buf[0];
      if (flag === WebsocketSignal.FINISH_SEND) {
        this.source.end();
        return;
      }
      let offset = 1;
      if (buf.length < HEADER_SIZE + offset) {
        return;
      }
      const header = buf.slice(offset, HEADER_SIZE + offset);
      const length = header.readUInt32BE(1);
      offset += HEADER_SIZE;
      if (buf.length < length + offset) {
        return;
      }
      const message = buf.slice(offset, offset + length);
      const deserialized = this.handler.deserialize(message);
      this.source.push(deserialized);
    });
    ws.once('end', () => {
      this.source.end();
      this.sink.end();
    });
  }
  sendMetadata(metadata) {
    this._ws.send(objectToHeaders(metadata));
  }
  sendMessage(message) {
    const response = this.handler.serialize(message);
    const header = new DataView(new ArrayBuffer(HEADER_SIZE));
    header.setUint32(1, response.byteLength);
    this._ws.send(Buffer.concat([
      new Uint8Array(header.buffer, header.byteOffset, header.byteLength),
      response
    ], header.byteLength + response.byteLength));
    this.sendTrailer();
  }
  sendTrailer(err) {
    const trailerBuffer = objectToHeaders({
      'grpc-status': err ? 1 : 0,
      'grpc-message': err ? err.message : undefined,
      'grpc-stack': err ? err.stack : undefined,
      'grpc-code': err ? err.code : undefined
    });
    const trailer = new DataView(new ArrayBuffer(HEADER_SIZE));
    trailer.setUint8(0, TRAILER_BYTES);
    trailer.setUint32(1, trailerBuffer.byteLength);
    this._ws.send(Buffer.concat([
      new Uint8Array(trailer.buffer, trailer.byteOffset, trailer.byteLength),
      trailerBuffer
    ], trailer.byteLength + trailerBuffer.byteLength));
  }
  end(err) {
    this.sendTrailer(err);
    this.source.end();
    this.sink.end();
    this._ws.close();
  }
}

exports.WebSocketMessageChannel = WebSocketMessageChannel;
