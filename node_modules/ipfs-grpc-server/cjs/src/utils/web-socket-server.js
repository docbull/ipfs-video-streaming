'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var WS = require('ws');
var events = require('events');
var webSocketMessageChannel = require('./web-socket-message-channel.js');
var debug = require('debug');
var coerce = require('coercer');
var changeCase = require('change-case');
var multiaddr = require('multiaddr');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var WS__default = /*#__PURE__*/_interopDefaultLegacy(WS);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var coerce__default = /*#__PURE__*/_interopDefaultLegacy(coerce);

const log = debug__default["default"]('ipfs:grpc-server:utils:web-socket-server');
const fromHeaders = buf => {
  const headers = buf.toString('utf8').trim().split('\r\n').map(s => s.split(':').map(s => s.trim())).reduce((acc, curr) => {
    if (curr[0] !== 'content-type' && curr[0] !== 'x-grpc-web') {
      acc[changeCase.camelCase(curr[0])] = curr[1];
    }
    return acc;
  }, {});
  return coerce__default["default"](headers);
};
class Messages extends events.EventEmitter {
  constructor(wss) {
    super();
    this._wss = wss;
    this.multiaddr = '';
    this.info = {
      uri: '',
      ma: new multiaddr.Multiaddr('/ip4/127.0.0.1/tcp/0/ws')
    };
    wss.on('connection', (ws, request) => {
      ws.on('error', error => log(`WebSocket Error: ${ error.stack }`));
      ws.once('message', buf => {
        const path = request.url;
        const metadata = fromHeaders(buf);
        const channel = new webSocketMessageChannel.WebSocketMessageChannel(ws);
        this.emit('data', {
          path,
          metadata,
          channel
        });
      });
    });
    wss.on('error', error => this.emit('error', error));
  }
  stop() {
    return new Promise((resolve, reject) => {
      this._wss.close(err => {
        if (err) {
          return reject(err);
        }
        resolve();
      });
    });
  }
  ready() {
    return new Promise(resolve => {
      this._wss.on('listening', () => {
        const info = this._wss.address();
        if (typeof info === 'string') {
          this.info = {
            uri: info,
            ma: new multiaddr.Multiaddr(info)
          };
        } else {
          this.info = {
            uri: `http://${ info.address }:${ info.port }`,
            ma: new multiaddr.Multiaddr(`/ip4/${ info.address }/tcp/${ info.port }/ws`)
          };
        }
        resolve(this);
      });
    });
  }
}
async function webSocketServer(ipfs, options = {}) {
  const config = await ipfs.config.getAll();
  const grpcAddr = config.Addresses?.RPC;
  if (!grpcAddr) {
    throw new Error('No gRPC address configured, please set an Addresses.RPC key in your IPFS config');
  }
  const [, , host, , port] = grpcAddr.split('/');
  log(`starting ws server on ${ host }:${ port }`);
  const wss = new WS__default["default"].Server({
    host,
    port: parseInt(port, 10)
  });
  const messages = new Messages(wss);
  return messages.ready();
}

exports.webSocketServer = webSocketServer;
