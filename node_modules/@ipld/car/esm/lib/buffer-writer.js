import varint from 'varint';
import {
  Token,
  Type
} from 'cborg';
import { tokensToLength } from 'cborg/length';
import * as CBOR from '@ipld/dag-cbor';
class CarBufferWriter {
  constructor(bytes, headerSize) {
    this.bytes = bytes;
    this.byteOffset = headerSize;
    this.roots = [];
    this.headerSize = headerSize;
  }
  addRoot(root, options) {
    addRoot(this, root, options);
    return this;
  }
  write(block) {
    addBlock(this, block);
    return this;
  }
  close(options) {
    return close(this, options);
  }
}
export const addRoot = (writer, root, {
  resize = false
} = {}) => {
  const {bytes, headerSize, byteOffset, roots} = writer;
  writer.roots.push(root);
  const size = headerLength(writer);
  if (size > headerSize) {
    if (size - headerSize + byteOffset < bytes.byteLength) {
      if (resize) {
        resizeHeader(writer, size);
      } else {
        roots.pop();
        throw new RangeError(`Header of size ${ headerSize } has no capacity for new root ${ root }.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
      }
    } else {
      roots.pop();
      throw new RangeError(`Buffer has no capacity for a new root ${ root }`);
    }
  }
};
export const blockLength = ({cid, bytes}) => {
  const size = cid.bytes.byteLength + bytes.byteLength;
  return varint.encodingLength(size) + size;
};
export const addBlock = (writer, {cid, bytes}) => {
  const byteLength = cid.bytes.byteLength + bytes.byteLength;
  const size = varint.encode(byteLength);
  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {
    throw new RangeError('Buffer has no capacity for this block');
  } else {
    writeBytes(writer, size);
    writeBytes(writer, cid.bytes);
    writeBytes(writer, bytes);
  }
};
export const close = (writer, {
  resize = false
} = {}) => {
  const {roots, bytes, byteOffset, headerSize} = writer;
  const headerBytes = CBOR.encode({
    version: 1,
    roots
  });
  const varintBytes = varint.encode(headerBytes.length);
  const size = varintBytes.length + headerBytes.byteLength;
  const offset = headerSize - size;
  if (offset === 0) {
    writeHeader(writer, varintBytes, headerBytes);
    return bytes.subarray(0, byteOffset);
  } else if (resize) {
    resizeHeader(writer, size);
    writeHeader(writer, varintBytes, headerBytes);
    return bytes.subarray(0, writer.byteOffset);
  } else {
    throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
  }
};
export const resizeHeader = (writer, byteLength) => {
  const {bytes, headerSize} = writer;
  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength);
  writer.byteOffset += byteLength - headerSize;
  writer.headerSize = byteLength;
};
const writeBytes = (writer, bytes) => {
  writer.bytes.set(bytes, writer.byteOffset);
  writer.byteOffset += bytes.length;
};
const writeHeader = ({bytes}, varint, header) => {
  bytes.set(varint);
  bytes.set(header, varint.length);
};
const headerPreludeTokens = [
  new Token(Type.map, 2),
  new Token(Type.string, 'version'),
  new Token(Type.uint, 1),
  new Token(Type.string, 'roots')
];
const CID_TAG = new Token(Type.tag, 42);
export const calculateHeaderLength = rootLengths => {
  const tokens = [...headerPreludeTokens];
  tokens.push(new Token(Type.array, rootLengths.length));
  for (const rootLength of rootLengths) {
    tokens.push(CID_TAG);
    tokens.push(new Token(Type.bytes, { length: rootLength + 1 }));
  }
  const length = tokensToLength(tokens);
  return varint.encodingLength(length) + length;
};
export const headerLength = ({roots}) => calculateHeaderLength(roots.map(cid => cid.bytes.byteLength));
export const estimateHeaderLength = (rootCount, rootByteLength = 36) => calculateHeaderLength(new Array(rootCount).fill(rootByteLength));
export const createWriter = (buffer, {roots = [], byteOffset = 0, byteLength = buffer.byteLength, headerSize = headerLength({ roots })} = {}) => {
  const bytes = new Uint8Array(buffer, byteOffset, byteLength);
  const writer = new CarBufferWriter(bytes, headerSize);
  for (const root of roots) {
    writer.addRoot(root);
  }
  return writer;
};