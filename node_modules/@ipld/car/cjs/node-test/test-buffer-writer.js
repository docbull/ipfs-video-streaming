'use strict';

var bufferWriter = require('../lib/buffer-writer.js');
var reader = require('../lib/reader.js');
var encoder = require('../lib/encoder.js');
var common = require('./common.js');
var multiformats = require('multiformats');
var CBOR = require('@ipld/dag-cbor');
var sha2 = require('multiformats/hashes/sha2');
var identity = require('multiformats/hashes/identity');
var raw = require('multiformats/codecs/raw');
var Block = require('multiformats/block');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var CBOR__namespace = /*#__PURE__*/_interopNamespace(CBOR);
var raw__namespace = /*#__PURE__*/_interopNamespace(raw);
var Block__namespace = /*#__PURE__*/_interopNamespace(Block);

describe('CarBufferWriter', () => {
  const cid = multiformats.CID.parse('bafkreifuosuzujyf4i6psbneqtwg2fhplc2wxptc5euspa2gn3bwhnihfu');
  describe('calculateHeaderLength', async () => {
    for (const count of [
        0,
        1,
        10,
        18,
        24,
        48,
        124,
        255,
        258,
        65536 - 1,
        65536
      ]) {
      it(`calculateHeaderLength(new Array(${ count }).fill(36))`, () => {
        const roots = new Array(count).fill(cid);
        const sizes = new Array(count).fill(cid.bytes.byteLength);
        common.assert.deepEqual(bufferWriter.calculateHeaderLength(sizes), encoder.createHeader(roots).byteLength);
      });
      it(`calculateHeaderLength(new Array(${ count }).fill(36))`, () => {
        const roots = new Array(count).fill(cid);
        const rootLengths = roots.map(c => c.bytes.byteLength);
        common.assert.deepEqual(bufferWriter.calculateHeaderLength(rootLengths), encoder.createHeader(roots).byteLength);
      });
    }
    it('estimate on large CIDs', () => {
      const largeCID = multiformats.CID.parse(`bafkqbbac${ 'a'.repeat(416) }`);
      common.assert.equal(bufferWriter.calculateHeaderLength([
        cid.bytes.byteLength,
        largeCID.bytes.byteLength
      ]), encoder.createHeader([
        cid,
        largeCID
      ]).byteLength);
    });
    it('estimate on large CIDs 2', () => {
      const largeCID = multiformats.CID.createV1(raw__namespace.code, identity.identity.digest(new Uint8Array(512).fill(1)));
      common.assert.equal(bufferWriter.calculateHeaderLength([
        cid.bytes.byteLength,
        largeCID.bytes.byteLength
      ]), encoder.createHeader([
        cid,
        largeCID
      ]).byteLength);
    });
  });
  describe('writer', () => {
    it('estimate header and write blocks', async () => {
      const headerSize = bufferWriter.estimateHeaderLength(1);
      const dataSize = 256;
      const buffer = new ArrayBuffer(headerSize + dataSize);
      const writer = bufferWriter.createWriter(buffer, { headerSize });
      const b1 = await Block__namespace.encode({
        value: { hello: 'world' },
        codec: CBOR__namespace,
        hasher: sha2.sha256
      });
      writer.write(b1);
      const b2 = await Block__namespace.encode({
        value: { bye: 'world' },
        codec: CBOR__namespace,
        hasher: sha2.sha256
      });
      writer.write(b2);
      writer.addRoot(b1.cid);
      const bytes = writer.close();
      const reader$1 = await reader.CarReader.fromBytes(bytes);
      common.assert.deepEqual(await reader$1.getRoots(), [b1.cid]);
      common.assert.deepEqual(reader$1._blocks, [
        {
          cid: b1.cid,
          bytes: b1.bytes
        },
        {
          cid: b2.cid,
          bytes: b2.bytes
        }
      ]);
    });
    it('overestimate header', async () => {
      const headerSize = bufferWriter.estimateHeaderLength(2);
      const dataSize = 256;
      const buffer = new ArrayBuffer(headerSize + dataSize);
      const writer = bufferWriter.createWriter(buffer, { headerSize });
      const b1 = await Block__namespace.encode({
        value: { hello: 'world' },
        codec: CBOR__namespace,
        hasher: sha2.sha256
      });
      writer.write(b1);
      const b2 = await Block__namespace.encode({
        value: { bye: 'world' },
        codec: CBOR__namespace,
        hasher: sha2.sha256
      });
      writer.write(b2);
      writer.addRoot(b1.cid);
      common.assert.throws(() => writer.close(), /Header size was overestimate/);
      const bytes = writer.close({ resize: true });
      const reader$1 = await reader.CarReader.fromBytes(bytes);
      common.assert.deepEqual(await reader$1.getRoots(), [b1.cid]);
      common.assert.deepEqual(reader$1._blocks, [
        {
          cid: b1.cid,
          bytes: b1.bytes
        },
        {
          cid: b2.cid,
          bytes: b2.bytes
        }
      ]);
    });
    it('underestimate header', async () => {
      const headerSize = bufferWriter.estimateHeaderLength(2);
      const dataSize = 300;
      const buffer = new ArrayBuffer(headerSize + dataSize);
      const writer = bufferWriter.createWriter(buffer, { headerSize });
      const b1 = await Block__namespace.encode({
        value: { hello: 'world' },
        codec: CBOR__namespace,
        hasher: sha2.sha256
      });
      writer.write(b1);
      writer.addRoot(b1.cid);
      const b2 = await Block__namespace.encode({
        value: { bye: 'world' },
        codec: CBOR__namespace,
        hasher: sha2.sha512
      });
      writer.write(b2);
      common.assert.throws(() => writer.addRoot(b2.cid), /has no capacity/);
      writer.addRoot(b2.cid, { resize: true });
      const bytes = writer.close();
      const reader$1 = await reader.CarReader.fromBytes(bytes);
      common.assert.deepEqual(await reader$1.getRoots(), [
        b1.cid,
        b2.cid
      ]);
      common.assert.deepEqual(reader$1._blocks, [
        {
          cid: b1.cid,
          bytes: b1.bytes
        },
        {
          cid: b2.cid,
          bytes: b2.bytes
        }
      ]);
    });
  });
  it('has no space for the root', async () => {
    const headerSize = bufferWriter.estimateHeaderLength(1);
    const dataSize = 100;
    const buffer = new ArrayBuffer(headerSize + dataSize);
    const writer = bufferWriter.createWriter(buffer, { headerSize });
    const b1 = await Block__namespace.encode({
      value: { hello: 'world' },
      codec: CBOR__namespace,
      hasher: sha2.sha256
    });
    writer.write(b1);
    writer.addRoot(b1.cid);
    const b2 = await Block__namespace.encode({
      value: { bye: 'world' },
      codec: CBOR__namespace,
      hasher: sha2.sha256
    });
    writer.write(b2);
    common.assert.throws(() => writer.addRoot(b2.cid), /Buffer has no capacity for a new root/);
    common.assert.throws(() => writer.addRoot(b2.cid, { resize: true }), /Buffer has no capacity for a new root/);
    const bytes = writer.close();
    const reader$1 = await reader.CarReader.fromBytes(bytes);
    common.assert.deepEqual(await reader$1.getRoots(), [b1.cid]);
    common.assert.deepEqual(reader$1._blocks, [
      {
        cid: b1.cid,
        bytes: b1.bytes
      },
      {
        cid: b2.cid,
        bytes: b2.bytes
      }
    ]);
  });
  it('has no space for the block', async () => {
    const headerSize = bufferWriter.estimateHeaderLength(1);
    const dataSize = 58;
    const buffer = new ArrayBuffer(headerSize + dataSize);
    const writer = bufferWriter.createWriter(buffer, { headerSize });
    const b1 = await Block__namespace.encode({
      value: { hello: 'world' },
      codec: CBOR__namespace,
      hasher: sha2.sha256
    });
    writer.write(b1);
    writer.addRoot(b1.cid);
    const b2 = await Block__namespace.encode({
      value: { bye: 'world' },
      codec: CBOR__namespace,
      hasher: sha2.sha256
    });
    common.assert.throws(() => writer.write(b2), /Buffer has no capacity for this block/);
    const bytes = writer.close();
    const reader$1 = await reader.CarReader.fromBytes(bytes);
    common.assert.deepEqual(await reader$1.getRoots(), [b1.cid]);
    common.assert.deepEqual(reader$1._blocks, [{
        cid: b1.cid,
        bytes: b1.bytes
      }]);
  });
  it('provide roots', async () => {
    const b1 = await Block__namespace.encode({
      value: { hello: 'world' },
      codec: CBOR__namespace,
      hasher: sha2.sha256
    });
    const b2 = await Block__namespace.encode({
      value: { bye: 'world' },
      codec: CBOR__namespace,
      hasher: sha2.sha512
    });
    const buffer = new ArrayBuffer(300);
    const writer = bufferWriter.createWriter(buffer, {
      roots: [
        b1.cid,
        b2.cid
      ]
    });
    writer.write(b1);
    writer.write(b2);
    const bytes = writer.close();
    const reader$1 = await reader.CarReader.fromBytes(bytes);
    common.assert.deepEqual(await reader$1.getRoots(), [
      b1.cid,
      b2.cid
    ]);
    common.assert.deepEqual(reader$1._blocks, [
      {
        cid: b1.cid,
        bytes: b1.bytes
      },
      {
        cid: b2.cid,
        bytes: b2.bytes
      }
    ]);
  });
  it('provide large CID root', async () => {
    const bytes = new Uint8Array(512).fill(1);
    const b1 = await Block__namespace.encode({
      value: { hello: 'world' },
      codec: CBOR__namespace,
      hasher: sha2.sha256
    });
    const b2 = {
      cid: multiformats.CID.createV1(raw__namespace.code, identity.identity.digest(bytes)),
      bytes
    };
    const headerSize = CBOR__namespace.encode({
      version: 1,
      roots: [
        b1.cid,
        b2.cid
      ]
    }).byteLength;
    const bodySize = bufferWriter.blockLength(b1) + bufferWriter.blockLength(b2);
    const varintSize = multiformats.varint.encodingLength(headerSize);
    const writer = bufferWriter.createWriter(new ArrayBuffer(varintSize + headerSize + bodySize), {
      roots: [
        b1.cid,
        b2.cid
      ]
    });
    writer.write(b1);
    writer.write(b2);
    const car = writer.close();
    const reader$1 = await reader.CarReader.fromBytes(car);
    common.assert.deepEqual(await reader$1.getRoots(), [
      b1.cid,
      b2.cid
    ]);
    common.assert.deepEqual(reader$1._blocks, [
      {
        cid: b1.cid,
        bytes: b1.bytes
      },
      {
        cid: b2.cid,
        bytes: b2.bytes
      }
    ]);
  });
});
