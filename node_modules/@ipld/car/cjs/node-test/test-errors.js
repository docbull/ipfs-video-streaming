'use strict';

var multiformats = require('multiformats');
var CBOR = require('@ipld/dag-cbor');
var varint = require('varint');
var reader = require('../lib/reader.js');
var common = require('./common.js');

function makeHeader(block) {
  const u = CBOR.encode(block);
  const l = varint.encode(u.length);
  const u2 = new Uint8Array(u.length + l.length);
  u2.set(l, 0);
  u2.set(u, l.length);
  return u2;
}
describe('Misc errors', () => {
  const buf = common.carBytes.slice();
  it('decode errors', async () => {
    const buf2 = new Uint8Array(buf.length);
    buf2.set(buf, 0);
    buf2[101] = 0;
    await common.assert.isRejected(reader.CarReader.fromBytes(buf2), {
      name: 'Error',
      message: 'Unexpected CID version (0)'
    });
  });
  it('bad version', async () => {
    const buf2 = multiformats.bytes.fromHex('0aa16776657273696f6e03');
    common.assert.strictEqual(multiformats.bytes.toHex(makeHeader({ version: 3 })), '0aa16776657273696f6e03');
    await common.assert.isRejected(reader.CarReader.fromBytes(buf2), Error, 'Invalid CAR version: 3');
  });
  describe('bad header', async () => {
    it('sanity check', async () => {
      const buf2 = makeHeader({
        version: 1,
        roots: []
      });
      await common.assert.isFulfilled(reader.CarReader.fromBytes(buf2));
    });
    it('no \'version\' array', async () => {
      const buf2 = makeHeader({ roots: [] });
      await common.assert.isRejected(reader.CarReader.fromBytes(buf2), Error, 'Invalid CAR header format');
    });
    it('bad \'version\' type', async () => {
      const buf2 = makeHeader({
        version: '1',
        roots: []
      });
      await common.assert.isRejected(reader.CarReader.fromBytes(buf2), Error, 'Invalid CAR header format');
    });
    it('no \'roots\' array', async () => {
      const buf2 = makeHeader({ version: 1 });
      await common.assert.isRejected(reader.CarReader.fromBytes(buf2), Error, 'Invalid CAR header format');
    });
    it('bad \'roots\' type', async () => {
      const buf2 = makeHeader({
        version: 1,
        roots: {}
      });
      await common.assert.isRejected(reader.CarReader.fromBytes(buf2), Error, 'Invalid CAR header format');
    });
    it('extraneous properties', async () => {
      const buf2 = makeHeader({
        version: 1,
        roots: [],
        blip: true
      });
      await common.assert.isRejected(reader.CarReader.fromBytes(buf2), Error, 'Invalid CAR header format');
    });
    it('not an object', async () => {
      const buf2 = makeHeader([
        1,
        []
      ]);
      await common.assert.isRejected(reader.CarReader.fromBytes(buf2), Error, 'Invalid CAR header format');
    });
    it('not an object', async () => {
      const buf2 = makeHeader(null);
      await common.assert.isRejected(reader.CarReader.fromBytes(buf2), Error, 'Invalid CAR header format');
    });
    it('recursive v2 header', async () => {
      const v2Header = common.goCarV2Bytes.slice(0, 51);
      const buf2 = new Uint8Array(51 * 2);
      buf2.set(v2Header, 0);
      buf2.set(v2Header, 51);
      await common.assert.isRejected(reader.CarReader.fromBytes(buf2), Error, 'Invalid CAR version: 2 (expected 1)');
    });
  });
});
