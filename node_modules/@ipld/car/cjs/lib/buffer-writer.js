'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var varint = require('varint');
var cborg = require('cborg');
var length = require('cborg/length');
var CBOR = require('@ipld/dag-cbor');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);
var CBOR__namespace = /*#__PURE__*/_interopNamespace(CBOR);

class CarBufferWriter {
  constructor(bytes, headerSize) {
    this.bytes = bytes;
    this.byteOffset = headerSize;
    this.roots = [];
    this.headerSize = headerSize;
  }
  addRoot(root, options) {
    addRoot(this, root, options);
    return this;
  }
  write(block) {
    addBlock(this, block);
    return this;
  }
  close(options) {
    return close(this, options);
  }
}
const addRoot = (writer, root, {
  resize = false
} = {}) => {
  const {bytes, headerSize, byteOffset, roots} = writer;
  writer.roots.push(root);
  const size = headerLength(writer);
  if (size > headerSize) {
    if (size - headerSize + byteOffset < bytes.byteLength) {
      if (resize) {
        resizeHeader(writer, size);
      } else {
        roots.pop();
        throw new RangeError(`Header of size ${ headerSize } has no capacity for new root ${ root }.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
      }
    } else {
      roots.pop();
      throw new RangeError(`Buffer has no capacity for a new root ${ root }`);
    }
  }
};
const blockLength = ({cid, bytes}) => {
  const size = cid.bytes.byteLength + bytes.byteLength;
  return varint__default["default"].encodingLength(size) + size;
};
const addBlock = (writer, {cid, bytes}) => {
  const byteLength = cid.bytes.byteLength + bytes.byteLength;
  const size = varint__default["default"].encode(byteLength);
  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {
    throw new RangeError('Buffer has no capacity for this block');
  } else {
    writeBytes(writer, size);
    writeBytes(writer, cid.bytes);
    writeBytes(writer, bytes);
  }
};
const close = (writer, {
  resize = false
} = {}) => {
  const {roots, bytes, byteOffset, headerSize} = writer;
  const headerBytes = CBOR__namespace.encode({
    version: 1,
    roots
  });
  const varintBytes = varint__default["default"].encode(headerBytes.length);
  const size = varintBytes.length + headerBytes.byteLength;
  const offset = headerSize - size;
  if (offset === 0) {
    writeHeader(writer, varintBytes, headerBytes);
    return bytes.subarray(0, byteOffset);
  } else if (resize) {
    resizeHeader(writer, size);
    writeHeader(writer, varintBytes, headerBytes);
    return bytes.subarray(0, writer.byteOffset);
  } else {
    throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
  }
};
const resizeHeader = (writer, byteLength) => {
  const {bytes, headerSize} = writer;
  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength);
  writer.byteOffset += byteLength - headerSize;
  writer.headerSize = byteLength;
};
const writeBytes = (writer, bytes) => {
  writer.bytes.set(bytes, writer.byteOffset);
  writer.byteOffset += bytes.length;
};
const writeHeader = ({bytes}, varint, header) => {
  bytes.set(varint);
  bytes.set(header, varint.length);
};
const headerPreludeTokens = [
  new cborg.Token(cborg.Type.map, 2),
  new cborg.Token(cborg.Type.string, 'version'),
  new cborg.Token(cborg.Type.uint, 1),
  new cborg.Token(cborg.Type.string, 'roots')
];
const CID_TAG = new cborg.Token(cborg.Type.tag, 42);
const calculateHeaderLength = rootLengths => {
  const tokens = [...headerPreludeTokens];
  tokens.push(new cborg.Token(cborg.Type.array, rootLengths.length));
  for (const rootLength of rootLengths) {
    tokens.push(CID_TAG);
    tokens.push(new cborg.Token(cborg.Type.bytes, { length: rootLength + 1 }));
  }
  const length$1 = length.tokensToLength(tokens);
  return varint__default["default"].encodingLength(length$1) + length$1;
};
const headerLength = ({roots}) => calculateHeaderLength(roots.map(cid => cid.bytes.byteLength));
const estimateHeaderLength = (rootCount, rootByteLength = 36) => calculateHeaderLength(new Array(rootCount).fill(rootByteLength));
const createWriter = (buffer, {roots = [], byteOffset = 0, byteLength = buffer.byteLength, headerSize = headerLength({ roots })} = {}) => {
  const bytes = new Uint8Array(buffer, byteOffset, byteLength);
  const writer = new CarBufferWriter(bytes, headerSize);
  for (const root of roots) {
    writer.addRoot(root);
  }
  return writer;
};

exports.addBlock = addBlock;
exports.addRoot = addRoot;
exports.blockLength = blockLength;
exports.calculateHeaderLength = calculateHeaderLength;
exports.close = close;
exports.createWriter = createWriter;
exports.estimateHeaderLength = estimateHeaderLength;
exports.headerLength = headerLength;
exports.resizeHeader = resizeHeader;
