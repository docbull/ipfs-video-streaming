'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var concat = require('uint8arrays/concat');
var toString = require('uint8arrays/to-string');
var drain = require('it-drain');
var Content = require('@hapi/content');
var multipart = require('it-multipart');
var qs = require('querystring');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);
var Content__default = /*#__PURE__*/_interopDefaultLegacy(Content);
var multipart__default = /*#__PURE__*/_interopDefaultLegacy(multipart);
var qs__default = /*#__PURE__*/_interopDefaultLegacy(qs);

const multipartFormdataType = 'multipart/form-data';
const applicationDirectory = 'application/x-directory';
const applicationSymlink = 'application/symlink';
const isDirectory = mediatype => mediatype === multipartFormdataType || mediatype === applicationDirectory;
const parseDisposition = disposition => {
  const details = {};
  details.type = disposition.split(';')[0];
  if (details.type === 'file' || details.type === 'form-data') {
    const filenamePattern = / filename="(.[^"]+)"/;
    const filenameMatches = disposition.match(filenamePattern);
    details.filename = filenameMatches ? filenameMatches[1] : '';
    const namePattern = / name="(.[^"]+)"/;
    const nameMatches = disposition.match(namePattern);
    details.name = nameMatches ? nameMatches[1] : '';
  }
  return details;
};
const collect = async stream => {
  const buffers = [];
  let size = 0;
  for await (const buf of stream) {
    size += buf.length;
    buffers.push(buf);
  }
  return concat.concat(buffers, size);
};
async function* parseEntry(stream) {
  for await (const part of stream) {
    if (!part.headers['content-type']) {
      throw new Error('No content-type in multipart part');
    }
    const type = Content__default["default"].type(part.headers['content-type']);
    if (!part.headers['content-disposition']) {
      throw new Error('No content disposition in multipart part');
    }
    const entry = {};
    if (isDirectory(type.mime)) {
      entry.type = 'directory';
    } else if (type.mime === applicationSymlink) {
      entry.type = 'symlink';
    } else {
      entry.type = 'file';
    }
    const disposition = parseDisposition(part.headers['content-disposition']);
    const query = qs__default["default"].parse(`${ disposition.name }`.split('?').pop() || '');
    if (query.mode) {
      entry.mode = parseInt(readQueryParam(query.mode), 8);
    }
    if (query.mtime) {
      entry.mtime = { secs: parseInt(readQueryParam(query.mtime), 10) };
      if (query['mtime-nsecs']) {
        entry.mtime.nsecs = parseInt(readQueryParam(query['mtime-nsecs']), 10);
      }
    }
    entry.name = decodeURIComponent(disposition.filename);
    entry.body = part.body;
    yield entry;
  }
}
const readQueryParam = value => Array.isArray(value) ? value[0] : value;
async function* multipartRequestParser(stream) {
  for await (const entry of parseEntry(multipart__default["default"](stream))) {
    if (entry.type === 'directory') {
      yield {
        type: 'directory',
        name: entry.name,
        mtime: entry.mtime,
        mode: entry.mode
      };
      await drain__default["default"](entry.body);
    }
    if (entry.type === 'symlink') {
      yield {
        type: 'symlink',
        name: entry.name,
        target: toString.toString(await collect(entry.body)),
        mtime: entry.mtime,
        mode: entry.mode
      };
    }
    if (entry.type === 'file') {
      yield {
        type: 'file',
        name: entry.name,
        content: entry.body,
        mtime: entry.mtime,
        mode: entry.mode
      };
    }
  }
}

exports.multipartRequestParser = multipartRequestParser;
