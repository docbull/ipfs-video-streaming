'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var stream = require('stream');
var itPipe = require('it-pipe');
var debug = require('debug');
var toIterable = require('stream-to-it');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var toIterable__default = /*#__PURE__*/_interopDefaultLegacy(toIterable);

const log = debug__default["default"]('ipfs:http-api:utils:stream-response');
const ERROR_TRAILER = 'X-Stream-Error';
async function streamResponse(request, h, getSource, options = {}) {
  const stream$1 = await new Promise(async (resolve, reject) => {
    let started = false;
    const stream$1 = new stream.PassThrough();
    try {
      await itPipe.pipe(async function* () {
        try {
          for await (const chunk of getSource()) {
            if (!started) {
              started = true;
              resolve(stream$1);
            }
            if (chunk instanceof Uint8Array || typeof chunk === 'string') {
              yield chunk;
            } else {
              yield JSON.stringify(chunk) + '\n';
            }
          }
          if (options.onEnd) {
            options.onEnd();
          }
        } catch (err) {
          log(err);
          if (options.onError) {
            options.onError(err);
          }
          if (request.raw.res.headersSent) {
            request.raw.res.addTrailers({
              [ERROR_TRAILER]: JSON.stringify({
                Message: err.message,
                Code: 0
              })
            });
          }
          reject(err);
        } finally {
          if (!started) {
            started = true;
            resolve(stream$1);
          }
          stream$1.end();
        }
      }(), toIterable__default["default"].sink(stream$1));
    } catch (err) {
      reject(err);
    }
  });
  return h.response(stream$1).header('X-Chunked-Output', '1').header('Content-Type', 'application/json').header('Trailer', ERROR_TRAILER);
}

exports.streamResponse = streamResponse;
