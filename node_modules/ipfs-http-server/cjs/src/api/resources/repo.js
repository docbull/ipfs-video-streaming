'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var joi = require('../../utils/joi.js');
var map = require('it-map');
var filter = require('it-filter');
var itPipe = require('it-pipe');
var streamResponse = require('../../utils/stream-response.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var map__default = /*#__PURE__*/_interopDefaultLegacy(map);
var filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);

const gcResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        streamErrors: joi.boolean().default(false),
        timeout: joi.timeout()
      }).rename('stream-errors', 'streamErrors', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {streamErrors, timeout}
    } = request;
    return streamResponse.streamResponse(request, h, () => itPipe.pipe(ipfs.repo.gc({
      signal,
      timeout
    }), async function* filterErrors(source) {
      yield* filter__default["default"](source, r => !r.err || streamErrors);
    }, async function* transformGcOutput(source) {
      yield* map__default["default"](source, r => ({
        Error: r.err && r.err.message || undefined,
        Key: !r.err && { '/': r.cid.toString() } || undefined
      }));
    }));
  }
};
const versionResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  handler: async (request, h) => {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const version = await ipfs.repo.version({
      signal,
      timeout
    });
    return h.response({ Version: version });
  }
};
const statResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  handler: async (request, h) => {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const stat = await ipfs.repo.stat({
      signal,
      timeout
    });
    return h.response({
      NumObjects: stat.numObjects.toString(),
      RepoSize: stat.repoSize.toString(),
      RepoPath: stat.repoPath,
      Version: stat.version,
      StorageMax: stat.storageMax.toString()
    });
  }
};

exports.gcResource = gcResource;
exports.statResource = statResource;
exports.versionResource = versionResource;
