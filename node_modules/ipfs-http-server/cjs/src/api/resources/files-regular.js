'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var multipartRequestParser = require('../../utils/multipart-request-parser.js');
var joi = require('../../utils/joi.js');
var Boom = require('@hapi/boom');
var itPipe = require('it-pipe');
var all = require('it-all');
var streamResponse = require('../../utils/stream-response.js');
var merge = require('it-merge');
var map = require('it-map');
var stream = require('stream');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var all__default = /*#__PURE__*/_interopDefaultLegacy(all);
var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);

const catResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        path: joi.ipfsPath().required(),
        offset: joi.number().integer().min(0),
        length: joi.number().integer().min(1),
        timeout: joi.timeout()
      }).rename('arg', 'path', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {path, offset, length, timeout}
    } = request;
    return streamResponse.streamResponse(request, h, () => ipfs.cat(path, {
      offset,
      length,
      timeout,
      signal
    }), {
      onError(err) {
        err.message = err.message === 'file does not exist' ? err.message : 'Failed to cat file: ' + err.message;
      }
    });
  }
};
const getResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        path: joi.ipfsPath().required(),
        archive: joi.boolean(),
        compress: joi.boolean(),
        compressionLevel: joi.number().integer().min(1).max(9),
        timeout: joi.timeout()
      }).rename('arg', 'path', {
        override: true,
        ignoreUndefined: true
      }).rename('compression-level', 'compressionLevel', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {path, archive, compress, compressionLevel, timeout}
    } = request;
    return streamResponse.streamResponse(request, h, () => ipfs.get(path, {
      timeout,
      archive,
      compress,
      compressionLevel,
      signal
    }));
  }
};
const addResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream',
      maxBytes: Number.MAX_SAFE_INTEGER
    },
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cidVersion: joi.number().integer().min(0).max(1),
        hashAlg: joi.string(),
        cidBase: joi.string().default('base58btc'),
        rawLeaves: joi.boolean(),
        onlyHash: joi.boolean(),
        pin: joi.boolean(),
        wrapWithDirectory: joi.boolean(),
        fileImportConcurrency: joi.number().integer().min(0),
        blockWriteConcurrency: joi.number().integer().min(0),
        shardSplitThreshold: joi.number().integer().min(0),
        chunker: joi.string(),
        trickle: joi.boolean(),
        preload: joi.boolean(),
        progress: joi.boolean()
      }).rename('cid-version', 'cidVersion', {
        override: true,
        ignoreUndefined: true
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('hash', 'hashAlg', {
        override: true,
        ignoreUndefined: true
      }).rename('raw-leaves', 'rawLeaves', {
        override: true,
        ignoreUndefined: true
      }).rename('only-hash', 'onlyHash', {
        override: true,
        ignoreUndefined: true
      }).rename('wrap-with-directory', 'wrapWithDirectory', {
        override: true,
        ignoreUndefined: true
      }).rename('file-import-concurrency', 'fileImportConcurrency', {
        override: true,
        ignoreUndefined: true
      }).rename('block-write-concurrency', 'blockWriteConcurrency', {
        override: true,
        ignoreUndefined: true
      }).rename('shard-split-threshold', 'shardSplitThreshold', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  handler(request, h) {
    if (!request.payload) {
      throw Boom__default["default"].badRequest('Array, Buffer, or String is required.');
    }
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cidVersion, cidBase, rawLeaves, progress, onlyHash, hashAlg, wrapWithDirectory, pin, chunker, trickle, preload, shardSplitThreshold, blockWriteConcurrency, timeout}
    } = request;
    let filesParsed = false;
    return streamResponse.streamResponse(request, h, () => itPipe.pipe(multipartRequestParser.multipartRequestParser(request.raw.req), async function* (source) {
      for await (const entry of source) {
        if (entry.type === 'file') {
          filesParsed = true;
          yield {
            path: entry.name,
            content: entry.content,
            mode: entry.mode,
            mtime: entry.mtime
          };
        }
        if (entry.type === 'directory') {
          filesParsed = true;
          yield {
            path: entry.name,
            mode: entry.mode,
            mtime: entry.mtime
          };
        }
      }
    }, async function* (source) {
      const progressStream = new stream.PassThrough({ objectMode: true });
      yield* merge__default["default"](progressStream, itPipe.pipe(ipfs.addAll(source, {
        cidVersion,
        rawLeaves,
        progress: progress ? (bytes, path) => {
          progressStream.write({
            Name: path,
            Bytes: bytes
          });
        } : () => {
        },
        onlyHash,
        hashAlg,
        wrapWithDirectory,
        pin,
        chunker,
        trickle,
        preload,
        shardSplitThreshold,
        fileImportConcurrency: 1,
        blockWriteConcurrency,
        signal,
        timeout
      }), async function* (source) {
        const base = await ipfs.bases.getBase(cidBase);
        yield* map__default["default"](source, file => {
          return {
            Name: file.path,
            Hash: file.cid.toString(base.encoder),
            Size: file.size,
            Mode: file.mode === undefined ? undefined : file.mode.toString(8).padStart(4, '0'),
            Mtime: file.mtime ? file.mtime.secs : undefined,
            MtimeNsecs: file.mtime ? file.mtime.nsecs : undefined
          };
        });
        progressStream.end();
      }));
    }), {
      onEnd() {
        if (!filesParsed) {
          throw Boom__default["default"].badRequest('File argument \'data\' is required.');
        }
      }
    });
  }
};
const lsResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        path: joi.ipfsPath().required(),
        cidBase: joi.string().default('base58btc'),
        stream: joi.boolean().default(false),
        timeout: joi.timeout()
      }).rename('arg', 'path', {
        override: true,
        ignoreUndefined: true
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {path, cidBase, stream, timeout}
    } = request;
    const base = await ipfs.bases.getBase(cidBase);
    const mapLink = link => {
      return {
        Hash: link.cid.toString(base.encoder),
        Size: link.size,
        Type: toTypeCode(link.type),
        Depth: link.depth,
        Name: link.name ? link.name : undefined,
        Mode: link.mode != null ? link.mode.toString(8).padStart(4, '0') : undefined,
        Mtime: link.mtime ? link.mtime.secs : undefined,
        MtimeNsecs: link.mtime ? link.mtime.nsecs : undefined
      };
    };
    const stat = await ipfs.files.stat(path.startsWith('/ipfs/') ? path : `/ipfs/${ path }`, {
      signal,
      timeout
    });
    if (stat.type === 'file') {
      return h.response({
        Objects: [{
            ...mapLink(stat),
            Hash: path,
            Depth: 1,
            Links: []
          }]
      });
    }
    if (!stream) {
      try {
        const links = await all__default["default"](ipfs.ls(path, {
          signal,
          timeout
        }));
        return h.response({
          Objects: [{
              Hash: path,
              Links: links.map(mapLink)
            }]
        });
      } catch (err) {
        throw Boom__default["default"].boomify(err, { message: 'Failed to list dir' });
      }
    }
    return streamResponse.streamResponse(request, h, () => itPipe.pipe(ipfs.ls(path, {
      signal,
      timeout
    }), async function* (source) {
      yield* map__default["default"](source, link => ({
        Objects: [{
            Hash: path,
            Links: [mapLink(link)]
          }]
      }));
    }));
  }
};
function toTypeCode(type) {
  switch (type) {
  case 'dir':
    return 1;
  case 'file':
    return 2;
  default:
    return 0;
  }
}
const refsResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        paths: joi.array().single().items(joi.ipfsPath()),
        recursive: joi.boolean().default(false),
        edges: joi.boolean().default(false),
        unique: joi.boolean().default(false),
        maxDepth: joi.number().integer().min(-1),
        format: joi.string(),
        timeout: joi.timeout()
      }).rename('max-depth', 'maxDepth', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'paths', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {paths, recursive, edges, unique, maxDepth, format, timeout}
    } = request;
    return streamResponse.streamResponse(request, h, () => itPipe.pipe(ipfs.refs(paths, {
      recursive,
      edges,
      unique,
      maxDepth,
      format,
      signal,
      timeout
    }), async function* (source) {
      yield* map__default["default"](source, ({ref, err}) => ({
        Ref: ref,
        Err: err
      }));
    }));
  }
};
const refsLocalResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    return streamResponse.streamResponse(request, h, () => itPipe.pipe(ipfs.refs.local({
      signal,
      timeout
    }), async function* (source) {
      yield* map__default["default"](source, ({ref, err}) => ({
        Ref: ref,
        Err: err
      }));
    }));
  }
};

exports.addResource = addResource;
exports.catResource = catResource;
exports.getResource = getResource;
exports.lsResource = lsResource;
exports.refsLocalResource = refsLocalResource;
exports.refsResource = refsResource;
