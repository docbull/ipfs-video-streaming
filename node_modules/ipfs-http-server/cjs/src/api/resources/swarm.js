'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var joi = require('../../utils/joi.js');

const peersResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        verbose: joi.boolean().default(false),
        direction: joi.boolean().default(false),
        timeout: joi.timeout()
      }).rename('v', 'verbose', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {verbose, direction, timeout}
    } = request;
    const peers = await ipfs.swarm.peers({
      verbose,
      signal,
      timeout
    });
    return h.response({
      Peers: peers.map(p => {
        return {
          Peer: p.peer.toString(),
          Addr: p.addr.toString(),
          Direction: verbose || direction ? p.direction : undefined,
          Muxer: verbose ? p.muxer : undefined,
          Latency: verbose ? p.latency : undefined
        };
      })
    });
  }
};
const addrsResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const peers = await ipfs.swarm.addrs({
      signal,
      timeout
    });
    return h.response({
      Addrs: peers.reduce((addrs, peer) => {
        addrs[peer.id.toString()] = peer.addrs.map(a => a.toString());
        return addrs;
      }, {})
    });
  }
};
const localAddrsResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const addrs = await ipfs.swarm.localAddrs({
      signal,
      timeout
    });
    return h.response({ Strings: addrs.map(addr => addr.toString()) });
  }
};
const connectResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        addr: joi.multiaddr().required(),
        timeout: joi.timeout()
      }).rename('arg', 'addr', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {addr, timeout}
    } = request;
    const controller = new AbortController();
    let connected = false;
    signal.addEventListener('abort', () => {
      if (!connected) {
        controller.abort();
      }
    });
    await ipfs.swarm.connect(addr, {
      signal: controller.signal,
      timeout
    });
    connected = true;
    return h.response({ Strings: [`connect ${ addr } success`] });
  }
};
const disconnectResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        addr: joi.multiaddr().required(),
        timeout: joi.timeout()
      }).rename('arg', 'addr', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {addr, timeout}
    } = request;
    await ipfs.swarm.disconnect(addr, {
      signal,
      timeout
    });
    return h.response({ Strings: [`disconnect ${ addr } success`] });
  }
};

exports.addrsResource = addrsResource;
exports.connectResource = connectResource;
exports.disconnectResource = disconnectResource;
exports.localAddrsResource = localAddrsResource;
exports.peersResource = peersResource;
