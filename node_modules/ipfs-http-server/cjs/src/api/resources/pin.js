'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var joi = require('../../utils/joi.js');
var Boom = require('@hapi/boom');
var map = require('it-map');
var itPipe = require('it-pipe');
var streamResponse = require('../../utils/stream-response.js');
var all = require('it-all');
var reduce = require('it-reduce');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);
var all__default = /*#__PURE__*/_interopDefaultLegacy(all);
var reduce__default = /*#__PURE__*/_interopDefaultLegacy(reduce);

function toPin(type, cid, metadata) {
  const output = { Type: type };
  if (cid) {
    output.Cid = cid;
  }
  if (metadata) {
    output.Metadata = metadata;
  }
  return output;
}
const lsResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        paths: joi.array().single().items(joi.ipfsPath()),
        recursive: joi.boolean().default(true),
        cidBase: joi.string().default('base58btc'),
        type: joi.string().valid('all', 'direct', 'indirect', 'recursive').default('all'),
        stream: joi.boolean().default(false),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'paths', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {paths, type, cidBase, stream, timeout}
    } = request;
    const source = ipfs.pin.ls({
      paths,
      type,
      signal,
      timeout
    });
    const base = await ipfs.bases.getBase(cidBase);
    if (!stream) {
      const res = await itPipe.pipe(source, function collectKeys(source) {
        const init = { Keys: {} };
        return reduce__default["default"](source, (res, {type, cid, metadata}) => {
          res.Keys[cid.toString(base.encoder)] = toPin(type, undefined, metadata);
          return res;
        }, init);
      });
      return h.response(res);
    }
    return streamResponse.streamResponse(request, h, () => itPipe.pipe(source, async function* transform(source) {
      yield* map__default["default"](source, ({type, cid, metadata}) => toPin(type, cid.toString(base.encoder), metadata));
    }));
  }
};
const addResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cids: joi.array().single().items(joi.cid()).min(1).required(),
        recursive: joi.boolean().default(true),
        cidBase: joi.string().default('base58btc'),
        timeout: joi.timeout(),
        metadata: joi.json()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'cids', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cids, recursive, cidBase, timeout, metadata}
    } = request;
    let result;
    try {
      result = await all__default["default"](ipfs.pin.addAll(cids.map(cid => ({
        cid,
        recursive,
        metadata
      })), {
        signal,
        timeout
      }));
    } catch (err) {
      if (err.code === 'ERR_BAD_PATH') {
        throw Boom__default["default"].boomify(err, { statusCode: 400 });
      }
      if (err.message.includes('already pinned recursively')) {
        throw Boom__default["default"].boomify(err, { statusCode: 400 });
      }
      throw Boom__default["default"].boomify(err, { message: 'Failed to add pin' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    return h.response({ Pins: result.map(cid => cid.toString(base.encoder)) });
  }
};
const rmResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cids: joi.array().single().items(joi.cid()).min(1).required(),
        recursive: joi.boolean().default(true),
        cidBase: joi.string().default('base58btc'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'cids', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cids, recursive, cidBase, timeout}
    } = request;
    let result;
    try {
      result = await all__default["default"](ipfs.pin.rmAll(cids.map(cid => ({
        cid,
        recursive
      })), {
        signal,
        timeout
      }));
    } catch (err) {
      if (err.code === 'ERR_BAD_PATH') {
        throw Boom__default["default"].boomify(err, { statusCode: 400 });
      }
      throw Boom__default["default"].boomify(err, { message: 'Failed to remove pin' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    return h.response({ Pins: result.map(cid => cid.toString(base.encoder)) });
  }
};

exports.addResource = addResource;
exports.lsResource = lsResource;
exports.rmResource = rmResource;
