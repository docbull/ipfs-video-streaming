'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var joi = require('../../utils/joi.js');
var all = require('it-all');
var multipartRequestParser = require('../../utils/multipart-request-parser.js');
var Boom = require('@hapi/boom');
var fromString = require('uint8arrays/from-string');
var toString = require('uint8arrays/to-string');
var streamResponse = require('../../utils/stream-response.js');
var pushable = require('it-pushable');
var base64 = require('multiformats/bases/base64');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var all__default = /*#__PURE__*/_interopDefaultLegacy(all);
var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var pushable__default = /*#__PURE__*/_interopDefaultLegacy(pushable);

const preDecodeTopicFromHttpRpc = {
  assign: 'topic',
  method: async (request, _h) => {
    try {
      return toString.toString(base64.base64url.decode(request.query.topic));
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: `Failed to decode topic  from HTTP RPC form ${ request.query.topic }` });
    }
  }
};
const subscribeResource = {
  options: {
    timeout: { socket: false },
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ topic: joi.string().required() }).rename('arg', 'topic', {
        override: true,
        ignoreUndefined: true
      })
    },
    pre: [preDecodeTopicFromHttpRpc]
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      pre: {topic}
    } = request;
    request.raw.res.setHeader('content-type', 'identity');
    return streamResponse.streamResponse(request, h, () => {
      const output = pushable__default["default"]();
      const handler = msg => {
        output.push({
          from: msg.from,
          data: base64.base64url.encode(msg.data),
          seqno: base64.base64url.encode(msg.seqno),
          topicIDs: msg.topicIDs.map(t => base64.base64url.encode(fromString.fromString(t)))
        });
      };
      output.push({});
      const unsubscribe = () => {
        ipfs.pubsub.unsubscribe(topic, handler);
        output.end();
      };
      request.raw.res.once('close', unsubscribe);
      ipfs.pubsub.subscribe(topic, handler, { signal }).catch(err => output.end(err));
      return output;
    });
  }
};
const publishResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    pre: [
      preDecodeTopicFromHttpRpc,
      {
        assign: 'data',
        method: async (request, _h) => {
          if (!request.payload) {
            throw Boom__default["default"].badRequest('argument "data" is required');
          }
          let data;
          for await (const part of multipartRequestParser.multipartRequestParser(request.raw.req)) {
            if (part.type === 'file') {
              data = Buffer.concat(await all__default["default"](part.content));
            }
          }
          if (!data || data.byteLength === 0) {
            throw Boom__default["default"].badRequest('argument "data" is required');
          }
          return data;
        }
      }
    ],
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        topic: joi.string().required(),
        discover: joi.boolean(),
        timeout: joi.timeout()
      }).rename('arg', 'topic', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      pre: {topic, data},
      query: {timeout}
    } = request;
    try {
      await ipfs.pubsub.publish(topic, data, {
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: `Failed to publish to topic ${ topic }` });
    }
    return h.response();
  }
};
const lsResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    let subscriptions;
    try {
      subscriptions = await ipfs.pubsub.ls({
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to list subscriptions' });
    }
    return h.response({ Strings: subscriptions.map(s => base64.base64url.encode(fromString.fromString(s))) });
  }
};
const peersResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        topic: joi.string().required(),
        timeout: joi.timeout()
      }).rename('arg', 'topic', {
        override: true,
        ignoreUndefined: true
      })
    },
    pre: [preDecodeTopicFromHttpRpc]
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      pre: {topic},
      query: {timeout}
    } = request;
    let peers;
    try {
      peers = await ipfs.pubsub.peers(topic, {
        signal,
        timeout
      });
    } catch (err) {
      const message = topic ? `Failed to find peers subscribed to ${ topic }: ${ err }` : `Failed to find peers: ${ err }`;
      throw Boom__default["default"].boomify(err, { message });
    }
    return h.response({ Strings: peers });
  }
};

exports.lsResource = lsResource;
exports.peersResource = peersResource;
exports.publishResource = publishResource;
exports.subscribeResource = subscribeResource;
