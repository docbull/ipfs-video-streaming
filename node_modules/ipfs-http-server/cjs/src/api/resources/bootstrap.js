'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Boom = require('@hapi/boom');
var joi = require('../../utils/joi.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);

const listResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  handler: async (request, h) => {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const list = await ipfs.bootstrap.list({
      timeout,
      signal
    });
    return h.response(list);
  }
};
const addResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        addr: joi.multiaddr(),
        default: joi.boolean().default(false),
        timeout: joi.timeout()
      }).rename('arg', 'addr', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {
        addr,
        default: def,
        timeout
      }
    } = request;
    let list;
    if (def) {
      list = await ipfs.bootstrap.reset({
        signal,
        timeout
      });
    } else if (addr) {
      list = await ipfs.bootstrap.add(addr, {
        signal,
        timeout
      });
    } else {
      throw Boom__default["default"].badRequest('arg is required');
    }
    return h.response(list);
  }
};
const addDefaultResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  handler: async (request, h) => {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const list = await ipfs.bootstrap.reset({
      signal,
      timeout
    });
    return h.response(list);
  }
};
const rmResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        addr: joi.multiaddr(),
        all: joi.boolean().default(false),
        timeout: joi.timeout()
      }).rename('arg', 'addr', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {addr, all, timeout}
    } = request;
    let list;
    if (all) {
      list = await ipfs.bootstrap.clear({
        signal,
        timeout
      });
    } else if (addr) {
      list = await ipfs.bootstrap.rm(addr, {
        signal,
        timeout
      });
    } else {
      throw Boom__default["default"].badRequest('arg is required');
    }
    return h.response(list);
  }
};
const rmAllResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  handler: async (request, h) => {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const list = await ipfs.bootstrap.clear({
      signal,
      timeout
    });
    return h.response(list);
  }
};

exports.addDefaultResource = addDefaultResource;
exports.addResource = addResource;
exports.listResource = listResource;
exports.rmAllResource = rmAllResource;
exports.rmResource = rmResource;
