'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var multipartRequestParser = require('../../utils/multipart-request-parser.js');
var streamResponse = require('../../utils/stream-response.js');
var joi = require('../../utils/joi.js');
var Boom = require('@hapi/boom');
var all = require('it-all');
var itPipe = require('it-pipe');
var toString = require('uint8arrays/to-string');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var all__default = /*#__PURE__*/_interopDefaultLegacy(all);

const encodeBufferKeys = (obj, encoding) => {
  if (!obj) {
    return obj;
  }
  if (obj instanceof Uint8Array) {
    return toString.toString(obj, encoding);
  }
  Object.keys(obj).forEach(key => {
    if (obj[key] instanceof Uint8Array) {
      obj[key] = toString.toString(obj[key], encoding);
      return;
    }
    if (typeof obj[key] === 'object') {
      obj[key] = encodeBufferKeys(obj[key], encoding);
    }
  });
  return obj;
};
const getResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        arg: joi.cidAndPath().required(),
        dataEncoding: joi.string().valid('ascii', 'base64pad', 'base16', 'utf8').replace(/text/, 'ascii').replace(/base64/, 'base64pad').replace(/hex/, 'base16').default('utf8'),
        timeout: joi.timeout()
      }).rename('data-encoding', 'dataEncoding', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {
        arg: {cid, path},
        dataEncoding,
        timeout
      }
    } = request;
    let result;
    try {
      result = await ipfs.dag.get(cid, {
        path,
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].badRequest(err);
    }
    let value = result.value;
    if (!(result.value instanceof Uint8Array) && result.value.toJSON) {
      value = result.value.toJSON();
    }
    try {
      result.value = encodeBufferKeys(value, dataEncoding);
    } catch (err) {
      throw Boom__default["default"].boomify(err);
    }
    return h.response(result.value);
  }
};
const putResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    pre: [{
        assign: 'args',
        method: async (request, _h) => {
          if (!request.payload) {
            throw Boom__default["default"].badRequest('File argument \'object data\' is required');
          }
          if (!request.headers['content-type']) {
            throw Boom__default["default"].badRequest('File argument \'object data\' is required');
          }
          let data;
          for await (const part of multipartRequestParser.multipartRequestParser(request.raw.req)) {
            if (part.type !== 'file') {
              continue;
            }
            data = Buffer.concat(await all__default["default"](part.content));
          }
          if (!data) {
            throw Boom__default["default"].badRequest('File argument \'object data\' is required');
          }
          return {
            data,
            hashAlg: request.query.hash
          };
        }
      }],
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        storeCodec: joi.string().default('dag-cbor'),
        inputCodec: joi.string().default('dag-json'),
        pin: joi.boolean().default(false),
        hash: joi.string().default('sha2-256'),
        cidBase: joi.string().default('base32'),
        version: joi.number().integer().valid(0, 1).default(1),
        timeout: joi.timeout()
      }).rename('store-codec', 'storeCodec', {
        override: true,
        ignoreUndefined: true
      }).rename('input-codec', 'inputCodec', {
        override: true,
        ignoreUndefined: true
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      pre: {
        args: {data, hashAlg}
      },
      query: {inputCodec, storeCodec, pin, cidBase, version, timeout}
    } = request;
    const cidVersion = storeCodec === 'dag-pb' && hashAlg === 'sha2-256' ? version : 1;
    let cid;
    try {
      cid = await ipfs.dag.put(data, {
        inputCodec,
        storeCodec,
        hashAlg,
        version: cidVersion,
        pin,
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to put node' });
    }
    const base = await ipfs.bases.getBase(cidVersion === 0 ? 'base58btc' : cidBase);
    return h.response({ Cid: { '/': cid.toString(base.encoder) } });
  }
};
const resolveResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        arg: joi.cidAndPath().required(),
        cidBase: joi.string().default('base58btc'),
        timeout: joi.timeout(),
        path: joi.string()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {
        arg: {cid, path},
        cidBase,
        timeout,
        path: queryPath
      }
    } = request;
    try {
      const result = await ipfs.dag.resolve(cid, {
        path: path || queryPath,
        signal,
        timeout
      });
      const base = await ipfs.bases.getBase(cidBase);
      return h.response({
        Cid: { '/': result.cid.toString(base.encoder) },
        RemPath: result.remainderPath
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err);
    }
  }
};
const exportResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        root: joi.cid().required(),
        timeout: joi.timeout()
      }).rename('arg', 'root', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {root, timeout}
    } = request;
    return streamResponse.streamResponse(request, h, () => ipfs.dag.export(root, {
      timeout,
      signal
    }), {
      onError(err) {
        err.message = 'Failed to export DAG: ' + err.message;
      }
    });
  }
};
const importResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream',
      maxBytes: Number.MAX_SAFE_INTEGER
    },
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        pinRoots: joi.boolean().default(true),
        timeout: joi.timeout()
      }).rename('pin-roots', 'pinRoots', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {pinRoots, timeout}
    } = request;
    let filesParsed = false;
    return streamResponse.streamResponse(request, h, () => itPipe.pipe(multipartRequestParser.multipartRequestParser(request.raw.req), async function* (source) {
      for await (const entry of source) {
        if (entry.type !== 'file') {
          throw Boom__default["default"].badRequest('Unexpected upload type');
        }
        filesParsed = true;
        yield entry.content;
      }
    }, async function* (source) {
      yield* ipfs.dag.import(source, {
        pinRoots,
        timeout,
        signal
      });
    }, async function* (source) {
      for await (const res of source) {
        yield {
          Root: {
            Cid: { '/': res.root.cid.toString() },
            PinErrorMsg: res.root.pinErrorMsg
          }
        };
      }
    }), {
      onError(err) {
        err.message = 'Failed to import DAG: ' + err.message;
      },
      onEnd() {
        if (!filesParsed) {
          throw Boom__default["default"].badRequest('File argument \'data\' is required.');
        }
      }
    });
  }
};

exports.exportResource = exportResource;
exports.getResource = getResource;
exports.importResource = importResource;
exports.putResource = putResource;
exports.resolveResource = resolveResource;
