'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var joi = require('../../../utils/joi.js');
var multipartRequestParser = require('../../../utils/multipart-request-parser.js');
var Boom = require('@hapi/boom');
var drain = require('it-drain');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);

const writeResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream',
      maxBytes: Number.MAX_SAFE_INTEGER
    },
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        arg: joi.string().regex(/^\/.+/).required(),
        offset: joi.number().integer().min(0),
        length: joi.number().integer().min(0),
        create: joi.boolean().default(false),
        truncate: joi.boolean().default(false),
        rawLeaves: joi.boolean().default(false),
        cidVersion: joi.number().integer().valid(0, 1).default(0),
        hashAlg: joi.string().default('sha2-256'),
        parents: joi.boolean().default(false),
        strategy: joi.string().valid('flat', 'balanced', 'trickle').default('trickle'),
        flush: joi.boolean().default(true),
        reduceSingleLeafToSelf: joi.boolean().default(false),
        shardSplitThreshold: joi.number().integer().min(0).default(1000),
        timeout: joi.timeout()
      }).rename('o', 'offset', {
        override: true,
        ignoreUndefined: true
      }).rename('e', 'create', {
        override: true,
        ignoreUndefined: true
      }).rename('t', 'truncate', {
        override: true,
        ignoreUndefined: true
      }).rename('shard-split-threshold', 'shardSplitThreshold', {
        override: true,
        ignoreUndefined: true
      }).rename('hash-alg', 'hashAlg', {
        override: true,
        ignoreUndefined: true
      }).rename('hash', 'hashAlg', {
        override: true,
        ignoreUndefined: true
      }).rename('cid-version', 'cidVersion', {
        override: true,
        ignoreUndefined: true
      }).rename('raw-leaves', 'rawLeaves', {
        override: true,
        ignoreUndefined: true
      }).rename('reduce-single-leaf-to-self', 'reduceSingleLeafToSelf', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {ipfs} = request.server.app;
    const {arg, offset, length, create, truncate, rawLeaves, reduceSingleLeafToSelf, cidVersion, hashAlg, parents, strategy, flush, shardSplitThreshold, timeout} = request.query;
    let files = 0;
    for await (const entry of multipartRequestParser.multipartRequestParser(request.raw.req)) {
      if (entry.type === 'file') {
        files++;
        if (files > 1) {
          throw Boom__default["default"].badRequest('Please only send one file');
        }
        await ipfs.files.write(arg, entry.content, {
          offset,
          length,
          create,
          truncate,
          rawLeaves,
          reduceSingleLeafToSelf,
          cidVersion,
          hashAlg,
          parents,
          strategy,
          flush,
          shardSplitThreshold,
          mode: entry.mode,
          mtime: entry.mtime,
          signal: request.app.signal,
          timeout
        });
        await drain__default["default"](entry.content);
      }
    }
    return h.response();
  }
};

exports.writeResource = writeResource;
