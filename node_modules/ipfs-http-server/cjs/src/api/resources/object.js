'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var multipartRequestParser = require('../../utils/multipart-request-parser.js');
var all = require('it-all');
var dagPB = require('@ipld/dag-pb');
var joi = require('../../utils/joi.js');
var Boom = require('@hapi/boom');
var fromString = require('uint8arrays/from-string');
var toString = require('uint8arrays/to-string');
var debug = require('debug');
var cid = require('multiformats/cid');
var base64 = require('multiformats/bases/base64');
var base16 = require('multiformats/bases/base16');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var all__default = /*#__PURE__*/_interopDefaultLegacy(all);
var dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);
var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = Object.assign(debug__default["default"]('ipfs:http-api:object'), { error: debug__default["default"]('ipfs:http-api:object:error') });
const DECODINGS = {
  ascii: str => fromString.fromString(str),
  utf8: str => fromString.fromString(str),
  base64pad: str => base64.base64pad.decode(`M${ str }`),
  base16: str => base16.base16.decode(`f${ str }`)
};
const readFilePart = async (request, _h) => {
  if (!request.payload) {
    throw Boom__default["default"].badRequest('File argument \'data\' is required');
  }
  let data;
  for await (const part of multipartRequestParser.multipartRequestParser(request.raw.req)) {
    if (part.type !== 'file') {
      continue;
    }
    data = Buffer.concat(await all__default["default"](part.content));
  }
  if (!data) {
    throw Boom__default["default"].badRequest('File argument \'data\' is required');
  }
  if (request.query.enc === 'json') {
    try {
      data = JSON.parse(data.toString('utf8'));
    } catch (err) {
      log(err);
      throw Boom__default["default"].badRequest('File argument \'data\' is required');
    }
  }
  return { data };
};
const newResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        template: joi.string().valid('unixfs-dir'),
        cidBase: joi.string().default('base32'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'template', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {template, cidBase, timeout}
    } = request;
    let cid, block, node;
    try {
      cid = await ipfs.object.new({
        template,
        signal,
        timeout
      });
      node = await ipfs.object.get(cid, {
        signal,
        timeout
      });
      block = dagPB__namespace.encode(node);
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to create object' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    const base58 = await ipfs.bases.getBase('base58btc');
    const answer = {
      Data: node.Data ? toString.toString(node.Data, 'base64pad') : '',
      Hash: cid.toString(cid.version === 1 ? base.encoder : base58.encoder),
      Size: block.length,
      Links: node.Links.map(l => {
        return {
          Name: l.Name,
          Size: l.Tsize,
          Hash: l.Hash.toString(l.Hash.version === 1 ? base.encoder : base58.encoder)
        };
      })
    };
    return h.response(answer);
  }
};
const getResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        cidBase: joi.string().default('base32'),
        dataEncoding: joi.string().valid('ascii', 'base64pad', 'base16', 'utf8').replace(/text/, 'ascii').replace(/base64/, 'base64pad').replace(/hex/, 'base16').default('base64pad'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('data-encoding', 'dataEncoding', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, cidBase, dataEncoding, timeout}
    } = request;
    let node, block;
    try {
      node = await ipfs.object.get(cid, {
        signal,
        timeout
      });
      block = dagPB__namespace.encode(node);
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to get object' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    const base58 = await ipfs.bases.getBase('base58btc');
    return h.response({
      Data: node.Data ? toString.toString(node.Data, dataEncoding) : '',
      Hash: cid.toString(cid.version === 1 ? base.encoder : base58.encoder),
      Size: block.length,
      Links: node.Links.map(l => {
        return {
          Name: l.Name,
          Size: l.Tsize,
          Hash: l.Hash.toString(l.Hash.version === 1 ? base.encoder : base58.encoder)
        };
      })
    });
  }
};
const putResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    pre: [{
        assign: 'args',
        method: readFilePart
      }],
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cidBase: joi.string().default('base32'),
        dataEncoding: joi.string().valid('ascii', 'base64pad', 'base16', 'utf8').replace(/text/, 'ascii').replace(/base64/, 'base64pad').replace(/hex/, 'base16').default('base64pad'),
        enc: joi.string().valid('json', 'protobuf').default('json'),
        pin: joi.boolean().default(false),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('datafieldenc', 'dataEncoding', {
        override: true,
        ignoreUndefined: true
      }).rename('inputenc', 'enc', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      pre: {
        args: {data}
      },
      query: {enc, cidBase, dataEncoding, timeout, pin}
    } = request;
    let input;
    if (enc === 'json') {
      input = {
        Data: data.Data ? DECODINGS[dataEncoding](data.Data) : undefined,
        Links: (data.Links || []).map(l => {
          return {
            Name: l.Name || '',
            Tsize: l.Size || l.Tsize || 0,
            Hash: cid.CID.parse(l.Hash)
          };
        })
      };
    } else {
      input = dagPB__namespace.decode(data);
    }
    let cid$1, node, block;
    try {
      cid$1 = await ipfs.object.put(input, {
        signal,
        timeout,
        pin
      });
      node = await ipfs.object.get(cid$1, {
        signal,
        timeout
      });
      block = dagPB__namespace.encode(node);
    } catch (err) {
      throw Boom__default["default"].badRequest(err, { message: 'Failed to put node' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    const base58 = await ipfs.bases.getBase('base58btc');
    const answer = {
      Data: node.Data ? toString.toString(node.Data, dataEncoding) : '',
      Hash: cid$1.toString(cid$1.version === 1 ? base.encoder : base58.encoder),
      Size: block.length,
      Links: node.Links.map(l => {
        return {
          Name: l.Name,
          Size: l.Tsize,
          Hash: l.Hash.toString(l.Hash.version === 1 ? base.encoder : base58.encoder)
        };
      })
    };
    return h.response(answer);
  }
};
const statResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        cidBase: joi.string().default('base32'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, cidBase, timeout}
    } = request;
    let stats;
    try {
      stats = await ipfs.object.stat(cid, {
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to stat object' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    const base58 = await ipfs.bases.getBase('base58btc');
    return h.response({
      ...stats,
      Hash: stats.Hash.toString(stats.Hash.version === 1 ? base.encoder : base58.encoder)
    });
  }
};
const dataResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        cidBase: joi.string().default('base32'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, timeout}
    } = request;
    let data;
    try {
      data = await ipfs.object.data(cid, {
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to get object data' });
    }
    return h.response(data);
  }
};
const linksResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        cidBase: joi.string().default('base32'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, cidBase, timeout}
    } = request;
    const links = await ipfs.object.links(cid, {
      signal,
      timeout
    });
    const base = await ipfs.bases.getBase(cidBase);
    const base58 = await ipfs.bases.getBase('base58btc');
    const response = {
      Hash: cid.toString(cid.version === 1 ? base.encoder : base58.encoder),
      Links: (links || []).map(l => {
        return {
          Name: l.Name,
          Size: l.Tsize,
          Hash: l.Hash.toString(l.Hash.version === 1 ? base.encoder : base58.encoder)
        };
      })
    };
    return h.response(response);
  }
};
const patchAppendDataResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    pre: [{
        assign: 'args',
        method: readFilePart
      }],
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        cidBase: joi.string().default('base32'),
        dataEncoding: joi.string().valid('ascii', 'base64pad', 'base16', 'utf8').replace(/text/, 'ascii').replace(/base64/, 'base64pad').replace(/hex/, 'base16').default('base64pad'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('data-encoding', 'dataEncoding', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      pre: {
        args: {data}
      },
      query: {cid, cidBase, dataEncoding, timeout}
    } = request;
    let newCid, node, block;
    try {
      newCid = await ipfs.object.patch.appendData(cid, data, {
        signal,
        timeout
      });
      node = await ipfs.object.get(newCid, {
        signal,
        timeout
      });
      block = dagPB__namespace.encode(node);
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to append data to object' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    const base58 = await ipfs.bases.getBase('base58btc');
    const answer = {
      Data: node.Data ? toString.toString(node.Data, dataEncoding) : '',
      Hash: newCid.toString(newCid.version === 1 ? base.encoder : base58.encoder),
      Size: block.length,
      Links: node.Links.map(l => {
        return {
          Name: l.Name,
          Size: l.Tsize,
          Hash: l.Hash.toString(l.Hash.version === 1 ? base.encoder : base58.encoder)
        };
      })
    };
    return h.response(answer);
  }
};
const patchSetDataResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    pre: [{
        assign: 'args',
        method: readFilePart
      }],
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        cidBase: joi.string().default('base32'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      pre: {
        args: {data}
      },
      query: {cid, cidBase, timeout}
    } = request;
    let newCid, node;
    try {
      newCid = await ipfs.object.patch.setData(cid, data, {
        signal,
        timeout
      });
      node = await ipfs.object.get(newCid, { signal: request.app.signal });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to set data on object' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    const base58 = await ipfs.bases.getBase('base58btc');
    return h.response({
      Hash: newCid.toString(newCid.version === 1 ? base.encoder : base58.encoder),
      Links: node.Links.map(l => {
        return {
          Name: l.Name,
          Size: l.Tsize,
          Hash: l.Hash.toString(l.Hash.version === 1 ? base.encoder : base58.encoder)
        };
      })
    });
  }
};
const patchAddLinkResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        args: joi.array().length(3).ordered(joi.cid().required(), joi.string().required(), joi.cid().required()).required(),
        cidBase: joi.string().default('base32'),
        dataEncoding: joi.string().valid('ascii', 'base64pad', 'base16', 'utf8').replace(/text/, 'ascii').replace(/base64/, 'base64pad').replace(/hex/, 'base16').default('base64pad'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'args', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {
        args: [root, name, ref],
        cidBase,
        dataEncoding,
        timeout
      }
    } = request;
    let node, cid, block;
    try {
      node = await ipfs.object.get(ref, {
        signal,
        timeout
      });
      block = dagPB__namespace.encode(node);
      cid = await ipfs.object.patch.addLink(root, {
        Name: name,
        Tsize: block.length,
        Hash: ref
      }, {
        signal,
        timeout
      });
      node = await ipfs.object.get(cid, {
        signal,
        timeout
      });
      block = dagPB__namespace.encode(node);
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to add link to object' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    const base58 = await ipfs.bases.getBase('base58btc');
    const answer = {
      Data: node.Data ? toString.toString(node.Data, dataEncoding) : '',
      Hash: cid.toString(cid.version === 1 ? base.encoder : base58.encoder),
      Size: block.length,
      Links: node.Links.map(l => {
        return {
          Name: l.Name,
          Size: l.Tsize,
          Hash: l.Hash.toString(l.Hash.version === 1 ? base.encoder : base58.encoder)
        };
      })
    };
    return h.response(answer);
  }
};
const patchRmLinkResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        args: joi.array().length(2).ordered(joi.cid().required(), joi.string().required()).required(),
        cidBase: joi.string().default('base32'),
        dataEncoding: joi.string().valid('ascii', 'base64pad', 'base16', 'utf8').replace(/text/, 'ascii').replace(/base64/, 'base64pad').replace(/hex/, 'base16').default('base64pad'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'args', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {
        args: [root, link],
        cidBase,
        dataEncoding,
        timeout
      }
    } = request;
    let cid, node, block;
    try {
      cid = await ipfs.object.patch.rmLink(root, link, {
        signal,
        timeout
      });
      node = await ipfs.object.get(cid, {
        signal,
        timeout
      });
      block = dagPB__namespace.encode(node);
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to remove link from object' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    const base58 = await ipfs.bases.getBase('base58btc');
    const answer = {
      Data: node.Data ? toString.toString(node.Data, dataEncoding) : '',
      Hash: cid.toString(cid.version === 1 ? base.encoder : base58.encoder),
      Size: block.length,
      Links: node.Links.map(l => {
        return {
          Name: l.Name,
          Size: l.Tsize,
          Hash: l.Hash.toString(l.Hash.version === 1 ? base.encoder : base58.encoder)
        };
      })
    };
    return h.response(answer);
  }
};

exports.dataResource = dataResource;
exports.getResource = getResource;
exports.linksResource = linksResource;
exports.newResource = newResource;
exports.patchAddLinkResource = patchAddLinkResource;
exports.patchAppendDataResource = patchAppendDataResource;
exports.patchRmLinkResource = patchRmLinkResource;
exports.patchSetDataResource = patchSetDataResource;
exports.putResource = putResource;
exports.statResource = statResource;
