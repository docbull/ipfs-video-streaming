'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debug = require('debug');
var get = require('dlv');
var set = require('just-safe-set');
var multipartRequestParser = require('../../utils/multipart-request-parser.js');
var Boom = require('@hapi/boom');
var joi = require('../../utils/joi.js');
var all = require('it-all');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var get__default = /*#__PURE__*/_interopDefaultLegacy(get);
var set__default = /*#__PURE__*/_interopDefaultLegacy(set);
var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var all__default = /*#__PURE__*/_interopDefaultLegacy(all);

const log = Object.assign(debug__default["default"]('ipfs:http-api:config'), { error: debug__default["default"]('ipfs:http-api:config:error') });
const getOrSetResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    pre: [{
        assign: 'args',
        method: (request, _h) => {
          const parseValue = args => {
            if (request.query.bool) {
              args.value = args.value === 'true';
            } else if (request.query.json) {
              try {
                args.value = JSON.parse(args.value);
              } catch (err) {
                log.error(err);
                throw Boom__default["default"].badRequest('failed to unmarshal json. ' + err);
              }
            }
            return args;
          };
          if (request.query.arg instanceof Array) {
            return parseValue({
              key: request.query.arg[0],
              value: request.query.arg[1]
            });
          }
          if (request.params.key) {
            return parseValue({
              key: request.params.key,
              value: request.query.arg
            });
          }
          if (!request.query.arg) {
            throw Boom__default["default"].badRequest('Argument \'key\' is required');
          }
          return { key: request.query.arg };
        }
      }],
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        arg: joi.array().single(),
        key: joi.string(),
        bool: joi.boolean().truthy(''),
        json: joi.boolean().truthy(''),
        timeout: joi.timeout()
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      pre: {
        args: {key, value}
      },
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    if (value && value.type === 'Buffer' && Array.isArray(value.data)) {
      throw Boom__default["default"].badRequest('Invalid value');
    }
    let originalConfig;
    try {
      originalConfig = await ipfs.config.getAll({
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to get config value' });
    }
    if (value === undefined) {
      const existingValue = get__default["default"](originalConfig, key);
      if (existingValue === undefined) {
        throw Boom__default["default"].notFound('Failed to get config value: key has no attributes');
      }
      return h.response({
        Key: key,
        Value: existingValue
      });
    }
    const result = set__default["default"](originalConfig, key, value);
    if (!result) {
      throw Boom__default["default"].badRequest('Failed to set config value');
    }
    try {
      await ipfs.config.replace(originalConfig, {
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to replace config value' });
    }
    return h.response({
      Key: key,
      Value: value
    });
  }
};
const getResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  handler: async (request, h) => {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    let config;
    try {
      config = await ipfs.config.getAll({
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to get config value' });
    }
    return h.response({ Value: config });
  }
};
const showResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  handler: async (request, h) => {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    let config;
    try {
      config = await ipfs.config.getAll({
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to get config value' });
    }
    return h.response(config);
  }
};
const replaceResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    pre: [{
        assign: 'args',
        method: async (request, _h) => {
          if (!request.payload) {
            throw Boom__default["default"].badRequest('Argument \'file\' is required');
          }
          let file;
          for await (const part of multipartRequestParser.multipartRequestParser(request.raw.req)) {
            if (part.type !== 'file') {
              continue;
            }
            file = Buffer.concat(await all__default["default"](part.content));
          }
          if (!file) {
            throw Boom__default["default"].badRequest('Argument \'file\' is required');
          }
          try {
            return { config: JSON.parse(file.toString('utf8')) };
          } catch (err) {
            throw Boom__default["default"].boomify(err, { message: 'Failed to decode file as config' });
          }
        }
      }],
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      pre: {
        args: {config}
      },
      query: {timeout}
    } = request;
    try {
      await ipfs.config.replace(config, {
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to save config' });
    }
    return h.response();
  }
};
const profilesApplyResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        profile: joi.string().required(),
        dryRun: joi.boolean().default(false),
        timeout: joi.timeout()
      }).rename('dry-run', 'dryRun', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'profile', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  handler: async function (request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {profile, dryRun, timeout}
    } = request;
    try {
      const diff = await ipfs.config.profiles.apply(profile, {
        dryRun,
        signal,
        timeout
      });
      return h.response({
        OldCfg: diff.original,
        NewCfg: diff.updated
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to apply profile' });
    }
  }
};
const profilesListResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  handler: async function (request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const list = await ipfs.config.profiles.list({
      signal,
      timeout
    });
    return h.response(list.map(profile => ({
      Name: profile.name,
      Description: profile.description
    })));
  }
};

exports.getOrSetResource = getOrSetResource;
exports.getResource = getResource;
exports.profilesApplyResource = profilesApplyResource;
exports.profilesListResource = profilesListResource;
exports.replaceResource = replaceResource;
exports.showResource = showResource;
