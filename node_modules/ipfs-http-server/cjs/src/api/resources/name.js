'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var joi = require('../../utils/joi.js');
var itPipe = require('it-pipe');
var map = require('it-map');
var last = require('it-last');
var streamResponse = require('../../utils/stream-response.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var map__default = /*#__PURE__*/_interopDefaultLegacy(map);
var last__default = /*#__PURE__*/_interopDefaultLegacy(last);

const resolveResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        name: joi.string(),
        nocache: joi.boolean().default(false),
        recursive: joi.boolean().default(true),
        stream: joi.boolean().default(false),
        timeout: joi.timeout()
      }).rename('arg', 'name', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {name, nocache, recursive, stream, timeout}
    } = request;
    if (!stream) {
      const value = await last__default["default"](ipfs.name.resolve(name, {
        nocache,
        recursive,
        signal,
        timeout
      }));
      return h.response({ Path: value });
    }
    return streamResponse.streamResponse(request, h, () => itPipe.pipe(ipfs.name.resolve(name, {
      nocache,
      recursive,
      signal,
      timeout
    }), async function* (source) {
      yield* map__default["default"](source, value => ({ Path: value }));
    }));
  }
};
const publishResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        name: joi.string().required(),
        resolve: joi.boolean().default(true),
        lifetime: joi.string().default('24h'),
        ttl: joi.string().allow(''),
        key: joi.string().default('self'),
        allowOffline: joi.boolean(),
        timeout: joi.timeout()
      }).rename('allow-offline', 'allowOffline', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'name', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {name, resolve, lifetime, ttl, key, allowOffline, timeout}
    } = request;
    const res = await ipfs.name.publish(name, {
      resolve,
      lifetime,
      ttl,
      key,
      allowOffline,
      signal,
      timeout
    });
    return h.response({
      Name: res.name,
      Value: res.value
    });
  }
};
const stateResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const res = await ipfs.name.pubsub.state({
      signal,
      timeout
    });
    return h.response({ Enabled: res.enabled });
  }
};
const pubsubSubsResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({ timeout: joi.timeout() })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {timeout}
    } = request;
    const res = await ipfs.name.pubsub.subs({
      signal,
      timeout
    });
    return h.response({ Strings: res });
  }
};
const pubsubCancelResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        topic: joi.string().required(),
        timeout: joi.timeout()
      }).rename('arg', 'topic', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {topic, timeout}
    } = request;
    const res = await ipfs.name.pubsub.cancel(topic, {
      signal,
      timeout
    });
    return h.response({ Canceled: res.canceled });
  }
};

exports.publishResource = publishResource;
exports.pubsubCancelResource = pubsubCancelResource;
exports.pubsubSubsResource = pubsubSubsResource;
exports.resolveResource = resolveResource;
exports.stateResource = stateResource;
