'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var joi = require('../../utils/joi.js');
var streamResponse = require('../../utils/stream-response.js');
var timeoutAbortController = require('timeout-abort-controller');
var anySignal = require('any-signal');
var toString = require('uint8arrays/to-string');
var multipartRequestParser = require('../../utils/multipart-request-parser.js');
var all = require('it-all');
var Boom = require('@hapi/boom');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var all__default = /*#__PURE__*/_interopDefaultLegacy(all);
var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);

function mapQueryEvent(id, event) {
  let extra = '';
  const type = event.type;
  let responses = null;
  if (event.name === 'SENDING_QUERY') {
    id = event.to;
  } else if (event.name === 'PEER_RESPONSE') {
    id = event.from;
    responses = event.closer.map(peerData => ({
      ID: peerData.id,
      Addrs: peerData.multiaddrs
    }));
  } else if (event.name === 'QUERY_ERROR') {
    id = event.from;
    extra = event.error.message;
  } else if (event.name === 'PROVIDER') {
    id = event.from;
    responses = event.providers.map(peerData => ({
      ID: peerData.id,
      Addrs: peerData.multiaddrs
    }));
  } else if (event.name === 'VALUE') {
    id = event.from;
    extra = toString.toString(event.value, 'base64pad');
  } else if (event.name === 'ADDING_PEER') {
    responses = [{
        ID: event.peer,
        Addrs: []
      }];
  } else if (event.name === 'DIALING_PEER') {
    id = event.peer;
  } else if (event.name === 'FINAL_PEER') {
    id = event.peer.id;
    responses = [{
        ID: event.peer.id,
        Addrs: event.peer.multiaddrs
      }];
  }
  return {
    Extra: extra,
    ID: id,
    Type: type,
    Responses: responses
  };
}
const findPeerResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        peerId: joi.string().required(),
        timeout: joi.timeout()
      }).rename('arg', 'peerId', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {peerId, timeout}
    } = request;
    const signals = [signal];
    let timeoutController;
    if (timeout != null) {
      timeoutController = new timeoutAbortController.TimeoutController(timeout);
      signals.push(timeoutController.signal);
    }
    const id = await ipfs.id({
      signal,
      timeout
    });
    return streamResponse.streamResponse(request, h, () => {
      return async function* () {
        for await (const event of ipfs.dht.findPeer(peerId, { signal: anySignal.anySignal(signals) })) {
          yield mapQueryEvent(id.id, event);
        }
        if (timeoutController) {
          timeoutController.clear();
        }
      }();
    });
  }
};
const findProvsResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        numProviders: joi.number().integer().default(20),
        timeout: joi.timeout()
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      }).rename('num-providers', 'numProviders', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, numProviders, timeout}
    } = request;
    const signals = [signal];
    let timeoutController;
    if (timeout != null) {
      timeoutController = new timeoutAbortController.TimeoutController(timeout);
      signals.push(timeoutController.signal);
    }
    const id = await ipfs.id({
      signal,
      timeout
    });
    const providers = new Set();
    return streamResponse.streamResponse(request, h, () => {
      return async function* () {
        for await (const event of ipfs.dht.findProvs(cid, { signal: anySignal.anySignal(signals) })) {
          if (event.name === 'PROVIDER') {
            event.providers.forEach(peerData => {
              providers.add(peerData.id);
            });
          }
          yield mapQueryEvent(id.id, event);
          if (providers.size >= numProviders) {
            break;
          }
        }
        if (timeoutController) {
          timeoutController.clear();
        }
      }();
    });
  }
};
const getResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        key: joi.string().required(),
        timeout: joi.timeout()
      }).rename('arg', 'key', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {key, timeout}
    } = request;
    const signals = [signal];
    let timeoutController;
    if (timeout != null) {
      timeoutController = new timeoutAbortController.TimeoutController(timeout);
      signals.push(timeoutController.signal);
    }
    const id = await ipfs.id({
      signal,
      timeout
    });
    return streamResponse.streamResponse(request, h, () => {
      return async function* () {
        for await (const event of ipfs.dht.get(key, { signal: anySignal.anySignal(signals) })) {
          yield mapQueryEvent(id.id, event);
        }
        if (timeoutController) {
          timeoutController.clear();
        }
      }();
    });
  }
};
const provideResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        timeout: joi.timeout()
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, timeout}
    } = request;
    const signals = [signal];
    let timeoutController;
    if (timeout != null) {
      timeoutController = new timeoutAbortController.TimeoutController(timeout);
      signals.push(timeoutController.signal);
    }
    const id = await ipfs.id({
      signal,
      timeout
    });
    return streamResponse.streamResponse(request, h, () => {
      return async function* () {
        for await (const event of ipfs.dht.provide(cid, { signal: anySignal.anySignal(signals) })) {
          yield mapQueryEvent(id.id, event);
        }
        if (timeoutController) {
          timeoutController.clear();
        }
      }();
    });
  }
};
const putResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    pre: [{
        assign: 'args',
        method: async (request, _h) => {
          if (!request.payload) {
            throw Boom__default["default"].badRequest('Argument \'file\' is required');
          }
          let value;
          for await (const part of multipartRequestParser.multipartRequestParser(request.raw.req)) {
            if (part.type !== 'file') {
              continue;
            }
            value = Buffer.concat(await all__default["default"](part.content));
          }
          if (!value) {
            throw Boom__default["default"].badRequest('Argument \'file\' is required');
          }
          try {
            return { value };
          } catch (err) {
            throw Boom__default["default"].boomify(err, { message: 'Failed to decode file as config' });
          }
        }
      }],
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        key: joi.string().required(),
        timeout: joi.timeout()
      }).rename('arg', 'key', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      pre: {
        args: {value}
      },
      query: {key, timeout}
    } = request;
    const signals = [signal];
    let timeoutController;
    if (timeout != null) {
      timeoutController = new timeoutAbortController.TimeoutController(timeout);
      signals.push(timeoutController.signal);
    }
    const id = await ipfs.id({
      signal,
      timeout
    });
    return streamResponse.streamResponse(request, h, () => {
      return async function* () {
        for await (const event of ipfs.dht.put(key, value, { signal: anySignal.anySignal(signals) })) {
          yield mapQueryEvent(id.id, event);
        }
        if (timeoutController) {
          timeoutController.clear();
        }
      }();
    });
  }
};
const queryResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        key: joi.string().required(),
        timeout: joi.timeout()
      }).rename('arg', 'key', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {key, timeout}
    } = request;
    const signals = [signal];
    let timeoutController;
    if (timeout != null) {
      timeoutController = new timeoutAbortController.TimeoutController(timeout);
      signals.push(timeoutController.signal);
    }
    const id = await ipfs.id({
      signal,
      timeout
    });
    return streamResponse.streamResponse(request, h, () => {
      return async function* () {
        for await (const event of ipfs.dht.query(key, { signal: anySignal.anySignal(signals) })) {
          yield mapQueryEvent(id.id, event);
        }
        if (timeoutController) {
          timeoutController.clear();
        }
      }();
    });
  }
};

exports.findPeerResource = findPeerResource;
exports.findProvsResource = findProvsResource;
exports.getResource = getResource;
exports.provideResource = provideResource;
exports.putResource = putResource;
exports.queryResource = queryResource;
