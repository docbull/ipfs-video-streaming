'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var multipartRequestParser = require('../../utils/multipart-request-parser.js');
var joi = require('../../utils/joi.js');
var Boom = require('@hapi/boom');
var all = require('it-all');
var itPipe = require('it-pipe');
var map = require('it-map');
var streamResponse = require('../../utils/stream-response.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);
var all__default = /*#__PURE__*/_interopDefaultLegacy(all);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);

const getResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        timeout: joi.timeout()
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, timeout}
    } = request;
    let block;
    try {
      block = await ipfs.block.get(cid, {
        timeout,
        signal
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to get block' });
    }
    if (!block) {
      throw Boom__default["default"].notFound('Block was unwanted before it could be remotely retrieved');
    }
    return h.response(Buffer.from(block.buffer, block.byteOffset, block.byteLength)).header('X-Stream-Output', '1');
  }
};
const putResource = {
  options: {
    payload: {
      parse: false,
      output: 'stream'
    },
    pre: [{
        assign: 'args',
        method: async (request, _h) => {
          if (!request.payload) {
            throw Boom__default["default"].badRequest('File argument \'data\' is required');
          }
          let data;
          for await (const part of multipartRequestParser.multipartRequestParser(request.raw.req)) {
            if (part.type !== 'file') {
              continue;
            }
            data = Buffer.concat(await all__default["default"](part.content));
          }
          if (!data) {
            throw Boom__default["default"].badRequest('File argument \'data\' is required');
          }
          return { data };
        }
      }],
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cidBase: joi.string().default('base32'),
        format: joi.string().default('dag-pb'),
        mhtype: joi.string().default('sha2-256'),
        mhlen: joi.number(),
        pin: joi.bool().default(false),
        version: joi.number().default(0),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      pre: {
        args: {data}
      },
      server: {
        app: {ipfs}
      },
      query: {mhtype, format, version, pin, timeout, cidBase}
    } = request;
    const codec = format === 'v0' ? 'dag-pb' : format;
    const cidVersion = codec === 'dag-pb' && mhtype === 'sha2-256' ? version : 1;
    let cid;
    try {
      cid = await ipfs.block.put(data, {
        mhtype,
        format: codec,
        version: cidVersion,
        pin,
        signal,
        timeout
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to put block' });
    }
    const base = await ipfs.bases.getBase(cidVersion === 0 ? 'base58btc' : cidBase);
    return h.response({
      Key: cid.toString(base.encoder),
      Size: data.length
    });
  }
};
const rmResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cids: joi.array().single().items(joi.cid()).min(1).required(),
        force: joi.boolean().default(false),
        quiet: joi.boolean().default(false),
        cidBase: joi.string().default('base58btc'),
        timeout: joi.timeout()
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      }).rename('arg', 'cids', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cids, force, quiet, timeout, cidBase}
    } = request;
    return streamResponse.streamResponse(request, h, () => itPipe.pipe(ipfs.block.rm(cids, {
      force,
      quiet,
      timeout,
      signal
    }), async function* (source) {
      const base = await ipfs.bases.getBase(cidBase);
      yield* map__default["default"](source, ({cid, error}) => ({
        Hash: cid.toString(base.encoder),
        Error: error ? error.message : undefined
      }));
    }));
  }
};
const statResource = {
  options: {
    validate: {
      options: {
        allowUnknown: true,
        stripUnknown: true
      },
      query: joi.object().keys({
        cid: joi.cid().required(),
        cidBase: joi.string().default('base58btc'),
        timeout: joi.timeout()
      }).rename('arg', 'cid', {
        override: true,
        ignoreUndefined: true
      }).rename('cid-base', 'cidBase', {
        override: true,
        ignoreUndefined: true
      })
    }
  },
  async handler(request, h) {
    const {
      app: {signal},
      server: {
        app: {ipfs}
      },
      query: {cid, cidBase, timeout}
    } = request;
    let stats;
    try {
      stats = await ipfs.block.stat(cid, {
        timeout,
        signal
      });
    } catch (err) {
      throw Boom__default["default"].boomify(err, { message: 'Failed to get block stats' });
    }
    const base = await ipfs.bases.getBase(cidBase);
    return h.response({
      Key: stats.cid.toString(base.encoder),
      Size: stats.size
    });
  }
};

exports.getResource = getResource;
exports.putResource = putResource;
exports.rmResource = rmResource;
exports.statResource = statResource;
