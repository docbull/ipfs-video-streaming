'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var Hapi = require('@hapi/hapi');
var Pino = require('hapi-pino');
var debug = require('debug');
var multiaddr = require('multiaddr');
var toMultiaddr = require('uri-to-multiaddr');
var Boom = require('@hapi/boom');
var index = require('./api/routes/index.js');
var errorHandler = require('./error-handler.js');
var events = require('events');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Hapi__default = /*#__PURE__*/_interopDefaultLegacy(Hapi);
var Pino__default = /*#__PURE__*/_interopDefaultLegacy(Pino);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var toMultiaddr__default = /*#__PURE__*/_interopDefaultLegacy(toMultiaddr);
var Boom__default = /*#__PURE__*/_interopDefaultLegacy(Boom);

const LOG = 'ipfs:http-api';
const LOG_ERROR = 'ipfs:http-api:error';
function hapiInfoToMultiaddr(info) {
  let hostname = info.host;
  let uri = info.uri;
  if (hostname.includes(':') && !hostname.startsWith('[')) {
    hostname = `[${ hostname }]`;
    uri = uri.replace(`://${ info.host }`, `://${ hostname }`);
  }
  return toMultiaddr__default["default"](uri);
}
async function serverCreator(serverAddrs, createServer, ipfs, cors) {
  serverAddrs = serverAddrs || [];
  serverAddrs = Array.isArray(serverAddrs) ? serverAddrs : [serverAddrs];
  const servers = [];
  for (const address of serverAddrs) {
    const addrParts = address.split('/');
    const server = await createServer(addrParts[2], addrParts[4], ipfs, cors);
    await server.start();
    server.info.ma = hapiInfoToMultiaddr(server.info);
    servers.push(server);
  }
  return servers;
}
function isAllowedOrigin(str, allowedOrigins = []) {
  if (!str) {
    return false;
  }
  let origin;
  try {
    origin = new URL(str).origin;
  } catch {
    return false;
  }
  for (const allowedOrigin of allowedOrigins) {
    if (allowedOrigin === '*') {
      return true;
    }
    if (allowedOrigin === origin) {
      return true;
    }
  }
  return false;
}
class HttpApi {
  constructor(ipfs) {
    this._ipfs = ipfs;
    this._log = Object.assign(debug__default["default"](LOG), { error: debug__default["default"](LOG_ERROR) });
    this._apiServers = [];
  }
  async start() {
    this._log('starting');
    const ipfs = this._ipfs;
    const config = await ipfs.config.getAll();
    const headers = config.API && config.API.HTTPHeaders || {};
    const apiAddrs = config.Addresses && config.Addresses.API || [];
    this._apiServers = await serverCreator(apiAddrs, this._createApiServer, ipfs, {
      origin: headers['Access-Control-Allow-Origin'] || [],
      credentials: Boolean(headers['Access-Control-Allow-Credentials'])
    });
    await ipfs.repo.setApiAddr(this._apiServers[0].info.ma);
    this._log('started');
  }
  async _createApiServer(host, port, ipfs, cors) {
    cors = {
      ...cors,
      additionalHeaders: [
        'X-Stream-Output',
        'X-Chunked-Output',
        'X-Content-Length'
      ],
      additionalExposedHeaders: [
        'X-Stream-Output',
        'X-Chunked-Output',
        'X-Content-Length'
      ]
    };
    const enableCors = Boolean(cors.origin?.length);
    const server = Hapi__default["default"].server({
      host,
      port,
      routes: {
        cors: enableCors ? cors : false,
        response: { emptyStatusCode: 200 }
      },
      compression: false
    });
    server.app.ipfs = ipfs;
    await server.register({
      plugin: Pino__default["default"],
      options: {
        prettyPrint: process.env.NODE_ENV !== 'production',
        logEvents: [
          'onPostStart',
          'onPostStop',
          'response',
          'request-error'
        ],
        level: debug__default["default"].enabled(LOG) ? 'debug' : debug__default["default"].enabled(LOG_ERROR) ? 'error' : 'fatal'
      }
    });
    server.ext({
      type: 'onRequest',
      method: function (request, h) {
        if (request.method === 'post' || request.method === 'options') {
          return h.continue;
        }
        if (request.method === 'get') {
          if (request.path.startsWith('/ipfs') || request.path.startsWith('/webui')) {
            return h.continue;
          }
          if (process.env.IPFS_MONITORING && request.path.startsWith('/debug')) {
            return h.continue;
          }
        }
        throw Boom__default["default"].methodNotAllowed();
      }
    });
    server.ext('onPreResponse', (request, h) => {
      const {response} = request;
      if (Boom__default["default"].isBoom(response) && response.output && response.output.statusCode === 405) {
        response.output.headers.Allow = 'OPTIONS, POST';
      }
      return h.continue;
    });
    server.ext({
      type: 'onRequest',
      method: function (request, h) {
        if (request.method !== 'post') {
          return h.continue;
        }
        const headers = request.headers || {};
        const origin = headers.origin || '';
        const referer = headers.referer || '';
        const userAgent = headers['user-agent'] || '';
        if (origin || referer) {
          if (!isAllowedOrigin(origin || referer, cors.origin)) {
            throw Boom__default["default"].forbidden();
          }
          return h.continue;
        }
        if (userAgent.includes('Electron')) {
          return h.continue;
        }
        if (!userAgent.startsWith('Mozilla')) {
          return h.continue;
        }
        throw Boom__default["default"].forbidden();
      }
    });
    server.ext({
      type: 'onRequest',
      method: function (request, h) {
        const controller = new AbortController();
        events.setMaxListeners && events.setMaxListeners(Infinity, controller.signal);
        request.app.signal = controller.signal;
        request.raw.res.once('close', () => {
          controller.abort();
        });
        request.events.once('disconnect', () => {
          controller.abort();
        });
        return h.continue;
      }
    });
    server.route(index.routes);
    errorHandler.errorHandler(server);
    return server;
  }
  get apiAddr() {
    if (!this._apiServers || !this._apiServers.length) {
      throw new Error('API address unavailable - server is not started');
    }
    return new multiaddr.Multiaddr('/ip4/127.0.0.1/tcp/' + this._apiServers[0].info.port);
  }
  async stop() {
    this._log('stopping');
    const stopServers = servers => Promise.all((servers || []).map(s => s.stop()));
    await Promise.all([stopServers(this._apiServers)]);
    this._log('stopped');
  }
}

exports.HttpApi = HttpApi;
