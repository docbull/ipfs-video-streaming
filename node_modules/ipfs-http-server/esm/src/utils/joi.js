import { CID } from 'multiformats/cid';
import parseDuration from 'parse-duration';
import { Multiaddr } from 'multiaddr';
import { toCidAndPath } from 'ipfs-core-utils/to-cid-and-path';
import Joi from 'joi';
const toIpfsPath = value => {
  if (!value) {
    throw new Error('Must have value');
  }
  value = value.toString();
  let startedWithIpfs = false;
  if (value.startsWith('/ipfs/')) {
    startedWithIpfs = true;
    value = value.replace(/^\/ipfs\//, '');
  }
  const parts = value.split('/');
  parts[0] = CID.parse(parts[0]);
  return `${ startedWithIpfs ? '/ipfs/' : '' }${ parts.join('/') }`;
};
const toCID = value => {
  return CID.parse(value.toString().replace('/ipfs/', ''));
};
const requireIfRequired = (value, helpers) => {
  if (helpers.schema.$_getFlag('presence') === 'required' && !value) {
    return {
      value,
      errors: helpers.error('required')
    };
  }
};
export default Joi.extend(joi => {
  return {
    type: 'cid',
    base: joi.any(),
    validate: requireIfRequired,
    coerce(value, _helpers) {
      if (!value) {
        return;
      }
      return { value: toCID(value) };
    }
  };
}, joi => {
  return {
    type: 'ipfsPath',
    base: joi.string(),
    validate: requireIfRequired,
    coerce(value, _helpers) {
      if (!value) {
        return;
      }
      return { value: toIpfsPath(value) };
    }
  };
}, joi => {
  return {
    type: 'multiaddr',
    base: joi.string(),
    validate: requireIfRequired,
    coerce(value, _helpers) {
      if (!value) {
        return;
      }
      return { value: new Multiaddr(value).toString() };
    }
  };
}, joi => {
  return {
    type: 'timeout',
    base: joi.number(),
    validate: requireIfRequired,
    coerce(value, _helpers) {
      if (!value) {
        return;
      }
      return { value: parseDuration(value) };
    }
  };
}, joi => {
  return {
    type: 'cidAndPath',
    base: joi.any(),
    validate: requireIfRequired,
    coerce(value, _helpers) {
      if (!value) {
        return;
      }
      return { value: toCidAndPath(value) };
    }
  };
}, joi => {
  return {
    type: 'json',
    base: joi.any(),
    validate: requireIfRequired,
    coerce(value, _helpers) {
      if (!value) {
        return;
      }
      return { value: JSON.parse(value) };
    }
  };
});