import { PassThrough } from 'stream';
import { pipe } from 'it-pipe';
import debug from 'debug';
import toIterable from 'stream-to-it';
const log = debug('ipfs:http-api:utils:stream-response');
const ERROR_TRAILER = 'X-Stream-Error';
export async function streamResponse(request, h, getSource, options = {}) {
  const stream = await new Promise(async (resolve, reject) => {
    let started = false;
    const stream = new PassThrough();
    try {
      await pipe(async function* () {
        try {
          for await (const chunk of getSource()) {
            if (!started) {
              started = true;
              resolve(stream);
            }
            if (chunk instanceof Uint8Array || typeof chunk === 'string') {
              yield chunk;
            } else {
              yield JSON.stringify(chunk) + '\n';
            }
          }
          if (options.onEnd) {
            options.onEnd();
          }
        } catch (err) {
          log(err);
          if (options.onError) {
            options.onError(err);
          }
          if (request.raw.res.headersSent) {
            request.raw.res.addTrailers({
              [ERROR_TRAILER]: JSON.stringify({
                Message: err.message,
                Code: 0
              })
            });
          }
          reject(err);
        } finally {
          if (!started) {
            started = true;
            resolve(stream);
          }
          stream.end();
        }
      }(), toIterable.sink(stream));
    } catch (err) {
      reject(err);
    }
  });
  return h.response(stream).header('X-Chunked-Output', '1').header('Content-Type', 'application/json').header('Trailer', ERROR_TRAILER);
}