import Hapi from '@hapi/hapi';
import Pino from 'hapi-pino';
import debug from 'debug';
import { Multiaddr } from 'multiaddr';
import toMultiaddr from 'uri-to-multiaddr';
import Boom from '@hapi/boom';
import { routes } from './api/routes/index.js';
import { errorHandler } from './error-handler.js';
import { setMaxListeners } from 'events';
const LOG = 'ipfs:http-api';
const LOG_ERROR = 'ipfs:http-api:error';
function hapiInfoToMultiaddr(info) {
  let hostname = info.host;
  let uri = info.uri;
  if (hostname.includes(':') && !hostname.startsWith('[')) {
    hostname = `[${ hostname }]`;
    uri = uri.replace(`://${ info.host }`, `://${ hostname }`);
  }
  return toMultiaddr(uri);
}
async function serverCreator(serverAddrs, createServer, ipfs, cors) {
  serverAddrs = serverAddrs || [];
  serverAddrs = Array.isArray(serverAddrs) ? serverAddrs : [serverAddrs];
  const servers = [];
  for (const address of serverAddrs) {
    const addrParts = address.split('/');
    const server = await createServer(addrParts[2], addrParts[4], ipfs, cors);
    await server.start();
    server.info.ma = hapiInfoToMultiaddr(server.info);
    servers.push(server);
  }
  return servers;
}
function isAllowedOrigin(str, allowedOrigins = []) {
  if (!str) {
    return false;
  }
  let origin;
  try {
    origin = new URL(str).origin;
  } catch {
    return false;
  }
  for (const allowedOrigin of allowedOrigins) {
    if (allowedOrigin === '*') {
      return true;
    }
    if (allowedOrigin === origin) {
      return true;
    }
  }
  return false;
}
export class HttpApi {
  constructor(ipfs) {
    this._ipfs = ipfs;
    this._log = Object.assign(debug(LOG), { error: debug(LOG_ERROR) });
    this._apiServers = [];
  }
  async start() {
    this._log('starting');
    const ipfs = this._ipfs;
    const config = await ipfs.config.getAll();
    const headers = config.API && config.API.HTTPHeaders || {};
    const apiAddrs = config.Addresses && config.Addresses.API || [];
    this._apiServers = await serverCreator(apiAddrs, this._createApiServer, ipfs, {
      origin: headers['Access-Control-Allow-Origin'] || [],
      credentials: Boolean(headers['Access-Control-Allow-Credentials'])
    });
    await ipfs.repo.setApiAddr(this._apiServers[0].info.ma);
    this._log('started');
  }
  async _createApiServer(host, port, ipfs, cors) {
    cors = {
      ...cors,
      additionalHeaders: [
        'X-Stream-Output',
        'X-Chunked-Output',
        'X-Content-Length'
      ],
      additionalExposedHeaders: [
        'X-Stream-Output',
        'X-Chunked-Output',
        'X-Content-Length'
      ]
    };
    const enableCors = Boolean(cors.origin?.length);
    const server = Hapi.server({
      host,
      port,
      routes: {
        cors: enableCors ? cors : false,
        response: { emptyStatusCode: 200 }
      },
      compression: false
    });
    server.app.ipfs = ipfs;
    await server.register({
      plugin: Pino,
      options: {
        prettyPrint: process.env.NODE_ENV !== 'production',
        logEvents: [
          'onPostStart',
          'onPostStop',
          'response',
          'request-error'
        ],
        level: debug.enabled(LOG) ? 'debug' : debug.enabled(LOG_ERROR) ? 'error' : 'fatal'
      }
    });
    server.ext({
      type: 'onRequest',
      method: function (request, h) {
        if (request.method === 'post' || request.method === 'options') {
          return h.continue;
        }
        if (request.method === 'get') {
          if (request.path.startsWith('/ipfs') || request.path.startsWith('/webui')) {
            return h.continue;
          }
          if (process.env.IPFS_MONITORING && request.path.startsWith('/debug')) {
            return h.continue;
          }
        }
        throw Boom.methodNotAllowed();
      }
    });
    server.ext('onPreResponse', (request, h) => {
      const {response} = request;
      if (Boom.isBoom(response) && response.output && response.output.statusCode === 405) {
        response.output.headers.Allow = 'OPTIONS, POST';
      }
      return h.continue;
    });
    server.ext({
      type: 'onRequest',
      method: function (request, h) {
        if (request.method !== 'post') {
          return h.continue;
        }
        const headers = request.headers || {};
        const origin = headers.origin || '';
        const referer = headers.referer || '';
        const userAgent = headers['user-agent'] || '';
        if (origin || referer) {
          if (!isAllowedOrigin(origin || referer, cors.origin)) {
            throw Boom.forbidden();
          }
          return h.continue;
        }
        if (userAgent.includes('Electron')) {
          return h.continue;
        }
        if (!userAgent.startsWith('Mozilla')) {
          return h.continue;
        }
        throw Boom.forbidden();
      }
    });
    server.ext({
      type: 'onRequest',
      method: function (request, h) {
        const controller = new AbortController();
        setMaxListeners && setMaxListeners(Infinity, controller.signal);
        request.app.signal = controller.signal;
        request.raw.res.once('close', () => {
          controller.abort();
        });
        request.events.once('disconnect', () => {
          controller.abort();
        });
        return h.continue;
      }
    });
    server.route(routes);
    errorHandler(server);
    return server;
  }
  get apiAddr() {
    if (!this._apiServers || !this._apiServers.length) {
      throw new Error('API address unavailable - server is not started');
    }
    return new Multiaddr('/ip4/127.0.0.1/tcp/' + this._apiServers[0].info.port);
  }
  async stop() {
    this._log('stopping');
    const stopServers = servers => Promise.all((servers || []).map(s => s.stop()));
    await Promise.all([stopServers(this._apiServers)]);
    this._log('stopped');
  }
}