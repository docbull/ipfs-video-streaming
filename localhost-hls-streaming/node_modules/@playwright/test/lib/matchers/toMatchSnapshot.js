"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toMatchSnapshot = toMatchSnapshot;

var _globals = require("../globals");

var _comparators = require("playwright-core/lib/utils/comparators");

var _util = require("../util");

var _safe = _interopRequireDefault(require("colors/safe"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var mime = _interopRequireWildcard(require("mime"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SNAPSHOT_COUNTER = Symbol('noname-snapshot-counter');

class SnapshotHelper {
  constructor(testInfo, anonymousSnapshotExtension, configOptions, nameOrOptions, optOptions) {
    var _mime$getType;

    this.testInfo = void 0;
    this.expectedPath = void 0;
    this.snapshotPath = void 0;
    this.actualPath = void 0;
    this.diffPath = void 0;
    this.mimeType = void 0;
    this.kind = void 0;
    this.updateSnapshots = void 0;
    this.comparatorOptions = void 0;
    this.allOptions = void 0;
    let options;
    let name;

    if (Array.isArray(nameOrOptions) || typeof nameOrOptions === 'string') {
      name = nameOrOptions;
      options = optOptions;
    } else {
      name = nameOrOptions.name;
      options = { ...nameOrOptions
      };
      delete options.name;
    }

    if (!name) {
      testInfo[SNAPSHOT_COUNTER] = (testInfo[SNAPSHOT_COUNTER] || 0) + 1;
      const fullTitleWithoutSpec = [...testInfo.titlePath.slice(1), testInfo[SNAPSHOT_COUNTER]].join(' ');
      name = (0, _util.sanitizeForFilePath)((0, _util.trimLongString)(fullTitleWithoutSpec)) + '.' + anonymousSnapshotExtension;
    }

    options = { ...configOptions,
      ...options
    };
    if (options.maxDiffPixels !== undefined && options.maxDiffPixels < 0) throw new Error('`maxDiffPixels` option value must be non-negative integer');
    if (options.maxDiffPixelRatio !== undefined && (options.maxDiffPixelRatio < 0 || options.maxDiffPixelRatio > 1)) throw new Error('`maxDiffPixelRatio` option value must be between 0 and 1'); // sanitizes path if string

    const pathSegments = Array.isArray(name) ? name : [(0, _util.addSuffixToFilePath)(name, '', undefined, true)];
    const snapshotPath = testInfo.snapshotPath(...pathSegments);
    const outputFile = testInfo.outputPath(...pathSegments);
    const expectedPath = (0, _util.addSuffixToFilePath)(outputFile, '-expected');
    const actualPath = (0, _util.addSuffixToFilePath)(outputFile, '-actual');
    const diffPath = (0, _util.addSuffixToFilePath)(outputFile, '-diff');
    let updateSnapshots = testInfo.config.updateSnapshots;
    if (updateSnapshots === 'missing' && testInfo.retry < testInfo.project.retries) updateSnapshots = 'none';
    const mimeType = (_mime$getType = mime.getType(_path.default.basename(snapshotPath))) !== null && _mime$getType !== void 0 ? _mime$getType : 'application/octet-string';
    const comparator = _comparators.mimeTypeToComparator[mimeType];
    if (!comparator) throw new Error('Failed to find comparator with type ' + mimeType + ': ' + snapshotPath);
    this.testInfo = testInfo;
    this.mimeType = mimeType;
    this.actualPath = actualPath;
    this.expectedPath = expectedPath;
    this.diffPath = diffPath;
    this.snapshotPath = snapshotPath;
    this.updateSnapshots = updateSnapshots;
    this.allOptions = options;
    this.comparatorOptions = {
      maxDiffPixels: options.maxDiffPixels,
      maxDiffPixelRatio: options.maxDiffPixelRatio,
      threshold: options.threshold
    };
    this.kind = this.mimeType.startsWith('image/') ? 'Screenshot' : 'Snapshot';
  }

  handleMissingNegated() {
    const isWriteMissingMode = this.updateSnapshots === 'all' || this.updateSnapshots === 'missing';
    const message = `${this.snapshotPath} is missing in snapshots${isWriteMissingMode ? ', matchers using ".not" won\'t write them automatically.' : '.'}`;
    return {
      // NOTE: 'isNot' matcher implies inversed value.
      pass: true,
      message: () => message
    };
  }

  handleDifferentNegated() {
    // NOTE: 'isNot' matcher implies inversed value.
    return {
      pass: false,
      message: () => ''
    };
  }

  handleMatchingNegated() {
    const message = [_safe.default.red(`${this.kind} comparison failed:`), '', indent('Expected result should be different from the actual one.', '  ')].join('\n'); // NOTE: 'isNot' matcher implies inversed value.

    return {
      pass: true,
      message: () => message
    };
  }

  handleMissing(actual) {
    const isWriteMissingMode = this.updateSnapshots === 'all' || this.updateSnapshots === 'missing';

    if (isWriteMissingMode) {
      writeFileSync(this.snapshotPath, actual);
      writeFileSync(this.actualPath, actual);
    }

    const message = `${this.snapshotPath} is missing in snapshots${isWriteMissingMode ? ', writing actual.' : '.'}`;

    if (this.updateSnapshots === 'all') {
      /* eslint-disable no-console */
      console.log(message);
      return {
        pass: true,
        message: () => message
      };
    }

    if (this.updateSnapshots === 'missing') {
      this.testInfo._failWithError((0, _util.serializeError)(new Error(message)), false
      /* isHardError */
      );

      return {
        pass: true,
        message: () => ''
      };
    }

    return {
      pass: false,
      message: () => message
    };
  }

  handleDifferent(actual, expected, diff, diffError, log, title = `${this.kind} comparison failed:`) {
    const output = [_safe.default.red(title), ''];

    if (diffError) {
      output.push(...[indent(diffError, '  '), '']);
    }

    if (log !== null && log !== void 0 && log.length) output.push((0, _util.callLogText)(log));

    if (expected !== undefined) {
      writeFileSync(this.expectedPath, expected);
      this.testInfo.attachments.push({
        name: 'expected',
        contentType: this.mimeType,
        path: this.expectedPath
      });
      output.push(`Expected: ${_safe.default.yellow(this.expectedPath)}`);
    }

    if (actual !== undefined) {
      writeFileSync(this.actualPath, actual);
      this.testInfo.attachments.push({
        name: 'actual',
        contentType: this.mimeType,
        path: this.actualPath
      });
      output.push(`Received: ${_safe.default.yellow(this.actualPath)}`);
    }

    if (diff !== undefined) {
      writeFileSync(this.diffPath, diff);
      this.testInfo.attachments.push({
        name: 'diff',
        contentType: this.mimeType,
        path: this.diffPath
      });
      output.push(`    Diff: ${_safe.default.yellow(this.diffPath)}`);
    }

    return {
      pass: false,
      message: () => output.join('\n')
    };
  }

  handleMatching() {
    return {
      pass: true,
      message: () => ''
    };
  }

}

function toMatchSnapshot(received, nameOrOptions = {}, optOptions = {}) {
  var _testInfo$project$exp;

  const testInfo = (0, _globals.currentTestInfo)();
  if (!testInfo) throw new Error(`toMatchSnapshot() must be called during the test`);
  const helper = new SnapshotHelper(testInfo, determineFileExtension(received), ((_testInfo$project$exp = testInfo.project.expect) === null || _testInfo$project$exp === void 0 ? void 0 : _testInfo$project$exp.toMatchSnapshot) || {}, nameOrOptions, optOptions);
  const comparator = _comparators.mimeTypeToComparator[helper.mimeType];
  if (!comparator) throw new Error('Failed to find comparator with type ' + helper.mimeType + ': ' + helper.snapshotPath);

  if (this.isNot) {
    if (!_fs.default.existsSync(helper.snapshotPath)) return helper.handleMissingNegated();
    const isDifferent = !!comparator(received, _fs.default.readFileSync(helper.snapshotPath), helper.comparatorOptions);
    return isDifferent ? helper.handleDifferentNegated() : helper.handleMatchingNegated();
  }

  if (!_fs.default.existsSync(helper.snapshotPath)) return helper.handleMissing(received);

  const expected = _fs.default.readFileSync(helper.snapshotPath);

  const result = comparator(received, expected, helper.comparatorOptions);
  if (!result) return helper.handleMatching();

  if (helper.updateSnapshots === 'all') {
    writeFileSync(helper.snapshotPath, received);
    /* eslint-disable no-console */

    console.log(helper.snapshotPath + ' does not match, writing actual.');
    return {
      pass: true,
      message: () => helper.snapshotPath + ' running with --update-snapshots, writing actual.'
    };
  }

  return helper.handleDifferent(received, expected, result.diff, result.errorMessage, undefined);
}

function writeFileSync(aPath, content) {
  _fs.default.mkdirSync(_path.default.dirname(aPath), {
    recursive: true
  });

  _fs.default.writeFileSync(aPath, content);
}

function indent(lines, tab) {
  return lines.replace(/^(?=.+$)/gm, tab);
}

function determineFileExtension(file) {
  if (typeof file === 'string') return 'txt';
  if (compareMagicBytes(file, [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a])) return 'png';
  if (compareMagicBytes(file, [0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01])) return 'jpg';
  return 'dat';
}

function compareMagicBytes(file, magicBytes) {
  return Buffer.compare(Buffer.from(magicBytes), file.slice(0, magicBytes.length)) === 0;
}