"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _core = require("@babel/core");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  return {
    name: 'playwright-debug-transform',
    visitor: {
      JSXElement(path) {
        const jsxElement = path.node;
        const jsxName = jsxElement.openingElement.name;
        if (!_core.types.isJSXIdentifier(jsxName)) return;
        const name = jsxName.name;
        const props = [];

        for (const jsxAttribute of jsxElement.openingElement.attributes) {
          if (_core.types.isJSXAttribute(jsxAttribute)) {
            if (!_core.types.isJSXIdentifier(jsxAttribute.name)) continue;
            const attrName = jsxAttribute.name.name;
            if (_core.types.isStringLiteral(jsxAttribute.value)) props.push(_core.types.objectProperty(_core.types.stringLiteral(attrName), jsxAttribute.value));else if (_core.types.isJSXExpressionContainer(jsxAttribute.value) && _core.types.isExpression(jsxAttribute.value.expression)) props.push(_core.types.objectProperty(_core.types.stringLiteral(attrName), jsxAttribute.value.expression));else props.push(_core.types.objectProperty(_core.types.stringLiteral(attrName), _core.types.nullLiteral()));
          } else if (_core.types.isJSXSpreadAttribute(jsxAttribute)) {
            props.push(_core.types.spreadElement(jsxAttribute.argument));
          }
        }

        const children = [];

        for (const child of jsxElement.children) {
          if (_core.types.isJSXText(child)) children.push(_core.types.stringLiteral(child.value));else if (_core.types.isJSXElement(child)) children.push(child);else if (_core.types.isJSXExpressionContainer(child) && !_core.types.isJSXEmptyExpression(child.expression)) children.push(child.expression);else if (_core.types.isJSXSpreadChild(child)) children.push(_core.types.spreadElement(child.expression));
        }

        path.replaceWith(_core.types.objectExpression([_core.types.objectProperty(_core.types.identifier('type'), _core.types.stringLiteral(name)), _core.types.objectProperty(_core.types.identifier('props'), _core.types.objectExpression(props)), _core.types.objectProperty(_core.types.identifier('children'), _core.types.arrayExpression(children))]));
      }

    }
  };
});

exports.default = _default;