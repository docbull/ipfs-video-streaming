'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cid = require('multiformats/cid');
var block = require('multiformats/block');
var writer = require('@ipld/car/writer');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var debug = require('debug');
var raw = require('multiformats/codecs/raw');
var json = require('multiformats/codecs/json');
var traversal = require('multiformats/traversal');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var raw__namespace = /*#__PURE__*/_interopNamespace(raw);
var json__namespace = /*#__PURE__*/_interopNamespace(json);

const log = debug__default["default"]('ipfs:components:dag:import');
const NO_LINKS_CODECS = [
  raw__namespace.code,
  json__namespace.code
];
function createExport({repo, preload, codecs}) {
  async function* dagExport(root, options = {}) {
    if (options.preload !== false) {
      preload(root);
    }
    const cid$1 = cid.CID.asCID(root);
    if (!cid$1) {
      throw new Error(`Unexpected error converting CID type: ${ root }`);
    }
    log(`Exporting ${ cid$1 } as car`);
    const {writer: writer$1, out} = await writer.CarWriter.create([cid$1]);
    let err = null;
    (async () => {
      try {
        const load = makeLoader(repo, writer$1, {
          signal: options.signal,
          timeout: options.timeout
        }, codecs);
        await traversal.walk({
          cid: cid$1,
          load
        });
      } catch (e) {
        err = e;
      } finally {
        writer$1.close();
      }
    })();
    for await (const chunk of out) {
      if (err) {
        break;
      }
      yield chunk;
    }
    if (err) {
      throw err;
    }
  }
  return withTimeoutOption.withTimeoutOption(dagExport);
}
function makeLoader(repo, writer, options, codecs) {
  return async cid => {
    const codec = await codecs.getCodec(cid.code);
    if (!codec) {
      throw new Error(`Can't decode links in block with codec 0x${ cid.code.toString(16) } to form complete DAG`);
    }
    const bytes = await repo.blocks.get(cid, options);
    log(`Adding block ${ cid } to car`);
    await writer.put({
      cid,
      bytes
    });
    if (NO_LINKS_CODECS.includes(cid.code)) {
      return null;
    }
    return block.createUnsafe({
      bytes,
      cid,
      codec
    });
  };
}

exports.createExport = createExport;
