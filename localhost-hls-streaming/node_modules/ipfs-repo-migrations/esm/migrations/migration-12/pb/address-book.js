import $protobuf from 'protobufjs/minimal.js';
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
const $root = $protobuf.roots['default'] || ($protobuf.roots['default'] = {});
export const Addresses = $root.Addresses = (() => {
  function Addresses(p) {
    this.addrs = [];
    if (p)
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
  }
  Addresses.prototype.addrs = $util.emptyArray;
  Addresses.prototype.certifiedRecord = null;
  Addresses.encode = function encode(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.addrs != null && m.addrs.length) {
      for (var i = 0; i < m.addrs.length; ++i)
        $root.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();
    }
    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, 'certifiedRecord'))
      $root.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
    return w;
  };
  Addresses.decode = function decode(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l, m = new $root.Addresses();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
      case 1:
        if (!(m.addrs && m.addrs.length))
          m.addrs = [];
        m.addrs.push($root.Addresses.Address.decode(r, r.uint32()));
        break;
      case 2:
        m.certifiedRecord = $root.Addresses.CertifiedRecord.decode(r, r.uint32());
        break;
      default:
        r.skipType(t & 7);
        break;
      }
    }
    return m;
  };
  Addresses.fromObject = function fromObject(d) {
    if (d instanceof $root.Addresses)
      return d;
    var m = new $root.Addresses();
    if (d.addrs) {
      if (!Array.isArray(d.addrs))
        throw TypeError('.Addresses.addrs: array expected');
      m.addrs = [];
      for (var i = 0; i < d.addrs.length; ++i) {
        if (typeof d.addrs[i] !== 'object')
          throw TypeError('.Addresses.addrs: object expected');
        m.addrs[i] = $root.Addresses.Address.fromObject(d.addrs[i]);
      }
    }
    if (d.certifiedRecord != null) {
      if (typeof d.certifiedRecord !== 'object')
        throw TypeError('.Addresses.certifiedRecord: object expected');
      m.certifiedRecord = $root.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
    }
    return m;
  };
  Addresses.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.addrs = [];
    }
    if (o.defaults) {
      d.certifiedRecord = null;
    }
    if (m.addrs && m.addrs.length) {
      d.addrs = [];
      for (var j = 0; j < m.addrs.length; ++j) {
        d.addrs[j] = $root.Addresses.Address.toObject(m.addrs[j], o);
      }
    }
    if (m.certifiedRecord != null && m.hasOwnProperty('certifiedRecord')) {
      d.certifiedRecord = $root.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
    }
    return d;
  };
  Addresses.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  Addresses.Address = function () {
    function Address(p) {
      if (p)
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
    }
    Address.prototype.multiaddr = $util.newBuffer([]);
    Address.prototype.isCertified = null;
    let $oneOfFields;
    Object.defineProperty(Address.prototype, '_isCertified', {
      get: $util.oneOfGetter($oneOfFields = ['isCertified']),
      set: $util.oneOfSetter($oneOfFields)
    });
    Address.encode = function encode(m, w) {
      if (!w)
        w = $Writer.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, 'multiaddr'))
        w.uint32(10).bytes(m.multiaddr);
      if (m.isCertified != null && Object.hasOwnProperty.call(m, 'isCertified'))
        w.uint32(16).bool(m.isCertified);
      return w;
    };
    Address.decode = function decode(r, l) {
      if (!(r instanceof $Reader))
        r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l, m = new $root.Addresses.Address();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
        case 1:
          m.multiaddr = r.bytes();
          break;
        case 2:
          m.isCertified = r.bool();
          break;
        default:
          r.skipType(t & 7);
          break;
        }
      }
      return m;
    };
    Address.fromObject = function fromObject(d) {
      if (d instanceof $root.Addresses.Address)
        return d;
      var m = new $root.Addresses.Address();
      if (d.multiaddr != null) {
        if (typeof d.multiaddr === 'string')
          $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);
        else if (d.multiaddr.length)
          m.multiaddr = d.multiaddr;
      }
      if (d.isCertified != null) {
        m.isCertified = Boolean(d.isCertified);
      }
      return m;
    };
    Address.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.multiaddr = '';
        else {
          d.multiaddr = [];
          if (o.bytes !== Array)
            d.multiaddr = $util.newBuffer(d.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty('multiaddr')) {
        d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      if (m.isCertified != null && m.hasOwnProperty('isCertified')) {
        d.isCertified = m.isCertified;
        if (o.oneofs)
          d._isCertified = 'isCertified';
      }
      return d;
    };
    Address.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return Address;
  }();
  Addresses.CertifiedRecord = function () {
    function CertifiedRecord(p) {
      if (p)
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
    }
    CertifiedRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    CertifiedRecord.prototype.raw = $util.newBuffer([]);
    CertifiedRecord.encode = function encode(m, w) {
      if (!w)
        w = $Writer.create();
      if (m.seq != null && Object.hasOwnProperty.call(m, 'seq'))
        w.uint32(8).uint64(m.seq);
      if (m.raw != null && Object.hasOwnProperty.call(m, 'raw'))
        w.uint32(18).bytes(m.raw);
      return w;
    };
    CertifiedRecord.decode = function decode(r, l) {
      if (!(r instanceof $Reader))
        r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l, m = new $root.Addresses.CertifiedRecord();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
        case 1:
          m.seq = r.uint64();
          break;
        case 2:
          m.raw = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
        }
      }
      return m;
    };
    CertifiedRecord.fromObject = function fromObject(d) {
      if (d instanceof $root.Addresses.CertifiedRecord)
        return d;
      var m = new $root.Addresses.CertifiedRecord();
      if (d.seq != null) {
        if ($util.Long)
          (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;
        else if (typeof d.seq === 'string')
          m.seq = parseInt(d.seq, 10);
        else if (typeof d.seq === 'number')
          m.seq = d.seq;
        else if (typeof d.seq === 'object')
          m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
      }
      if (d.raw != null) {
        if (typeof d.raw === 'string')
          $util.base64.decode(d.raw, m.raw = $util.newBuffer($util.base64.length(d.raw)), 0);
        else if (d.raw.length)
          m.raw = d.raw;
      }
      return m;
    };
    CertifiedRecord.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if ($util.Long) {
          var n = new $util.Long(0, 0, true);
          d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
        } else
          d.seq = o.longs === String ? '0' : 0;
        if (o.bytes === String)
          d.raw = '';
        else {
          d.raw = [];
          if (o.bytes !== Array)
            d.raw = $util.newBuffer(d.raw);
        }
      }
      if (m.seq != null && m.hasOwnProperty('seq')) {
        if (typeof m.seq === 'number')
          d.seq = o.longs === String ? String(m.seq) : m.seq;
        else
          d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
      }
      if (m.raw != null && m.hasOwnProperty('raw')) {
        d.raw = o.bytes === String ? $util.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
      }
      return d;
    };
    CertifiedRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return CertifiedRecord;
  }();
  return Addresses;
})();
export {
  $root as default
};