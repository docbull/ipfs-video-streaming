"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptStream = exports.encryptStream = void 0;
const constants_1 = require("./constants");
// Returns generator that encrypts payload from the user
function encryptStream(handshake) {
    return async function* (source) {
        for await (const chunk of source) {
            for (let i = 0; i < chunk.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
                if (end > chunk.length) {
                    end = chunk.length;
                }
                const data = handshake.encrypt(chunk.slice(i, end), handshake.session);
                yield data;
            }
        }
    };
}
exports.encryptStream = encryptStream;
// Decrypt received payload to the user
function decryptStream(handshake) {
    return async function* (source) {
        for await (const chunk of source) {
            for (let i = 0; i < chunk.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {
                let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;
                if (end > chunk.length) {
                    end = chunk.length;
                }
                const { plaintext: decrypted, valid } = await handshake.decrypt(chunk.slice(i, end), handshake.session);
                if (!valid) {
                    throw new Error('Failed to validate decrypted chunk');
                }
                yield decrypted;
            }
        }
    };
}
exports.decryptStream = decryptStream;
//# sourceMappingURL=crypto.js.map