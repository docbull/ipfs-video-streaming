import { expect } from 'aegir/utils/chai.js';
import sinon from 'sinon';
import errcode from 'err-code';
import isNode from 'detect-node';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { PubsubDatastore } from '../src/index.js';
import { Key } from 'interface-datastore';
import { MemoryDatastore } from 'datastore-core';
import {
  createPubsubNode,
  connectPubsubNodes,
  waitFor,
  waitForPeerToSubscribe
} from './utils.js';
import { Record } from 'libp2p-record';
import {
  keyToTopic,
  topicToKey
} from '../src/utils.js';
const smoothValidator = {
  validate: () => {
    return Promise.resolve();
  },
  select: () => {
    return 0;
  }
};
describe('datastore-pubsub', function () {
  this.timeout(60 * 1000);
  if (!isNode)
    return;
  let pubsubA;
  let datastoreA;
  let peerIdA;
  const registrarRecordA = {};
  let pubsubB;
  let datastoreB;
  let peerIdB;
  const registrarRecordB = {};
  before(async () => {
    [pubsubA, pubsubB] = await Promise.all([
      createPubsubNode(registrarRecordA),
      createPubsubNode(registrarRecordB)
    ]);
    peerIdA = pubsubA.peerId;
    peerIdB = pubsubB.peerId;
    await connectPubsubNodes({
      router: pubsubA,
      registrar: registrarRecordA
    }, {
      router: pubsubB,
      registrar: registrarRecordB
    });
    datastoreA = new MemoryDatastore();
    datastoreB = new MemoryDatastore();
  });
  const value = 'value';
  let testCounter = 0;
  let keyRef = '';
  let key;
  let record;
  let serializedRecord;
  beforeEach(() => {
    keyRef = `key${ testCounter }`;
    key = new Key(keyRef).uint8Array();
    record = new Record(key, uint8ArrayFromString(value));
    serializedRecord = record.serialize();
  });
  afterEach(() => {
    ++testCounter;
  });
  after(() => {
    return Promise.all([
      pubsubA.stop(),
      pubsubB.stop()
    ]);
  });
  it('should subscribe the topic, but receive error as no entry is stored locally', async () => {
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const subsTopic = keyToTopic(`/${ keyRef }`);
    let subscribers = await pubsubA.getTopics();
    expect(subscribers).to.exist();
    expect(subscribers).to.not.include(subsTopic);
    await expect(dsPubsubA.get(key)).to.eventually.be.rejected().with.property('code', 'ERR_NOT_FOUND');
    subscribers = await pubsubA.getTopics();
    expect(subscribers).to.exist();
    expect(subscribers).to.include(subsTopic);
  });
  it('should put correctly to node A and node B should not receive it without subscribing', async () => {
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, smoothValidator);
    const subsTopic = keyToTopic(`/${ keyRef }`);
    const res = await pubsubB.getTopics();
    expect(res).to.exist();
    expect(res).to.not.include(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await dsPubsubB.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    });
  });
  it('should validate if record content is the same', async () => {
    const customValidator = {
      validate: data => {
        const receivedRecord = Record.deserialize(data);
        expect(receivedRecord.value.toString()).to.equal(value);
        if (receivedRecord.value.toString() === value) {
          return Promise.resolve();
        }
        return Promise.reject(new Error('invalid record'));
      },
      select: () => {
        return 0;
      }
    };
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    const subsTopic = keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    await expect(dsPubsubB.get(key)).to.eventually.be.rejected().with.property('code', 'ERR_NOT_FOUND');
    await waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await waitFor(() => receivedMessage === true);
    const record = await dsPubsubB.get(key);
    expect(record).to.be.ok();
  });
  it('should put correctly to daemon A and daemon B should receive it as it tried to get it first and subscribed it', async () => {
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, smoothValidator);
    const subsTopic = keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    const res = await pubsubB.getTopics();
    expect(res).to.exist();
    expect(res).to.not.include(subsTopic);
    await dsPubsubB.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await waitFor(() => receivedMessage === true);
    const result = await dsPubsubB.get(key);
    expect(result).to.exist();
    const receivedRecord = Record.deserialize(result);
    expect(receivedRecord.value.toString()).to.equal(value);
  });
  it('should fail to create the PubsubDatastore if no validator is provided', () => {
    let dsPubsubB;
    try {
      dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB);
    } catch (err) {
      expect(err.code).to.equal('ERR_INVALID_PARAMETERS');
    }
    expect(dsPubsubB).to.equal(undefined);
  });
  it('should fail to create the PubsubDatastore if no validate function is provided', () => {
    const customValidator = {
      validate: undefined,
      select: () => {
        return 0;
      }
    };
    let dsPubsubB;
    try {
      dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    } catch (err) {
      expect(err.code).to.equal('ERR_INVALID_PARAMETERS');
    }
    expect(dsPubsubB).to.equal(undefined);
  });
  it('should fail to create the PubsubDatastore if no select function is provided', () => {
    const customValidator = {
      validate: () => {
        return true;
      },
      select: undefined
    };
    let dsPubsubB;
    try {
      dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    } catch (err) {
      expect(err.code).to.equal('ERR_INVALID_PARAMETERS');
    }
    expect(dsPubsubB).to.equal(undefined);
  });
  it('should fail if it fails getTopics to validate the record', async () => {
    const customValidator = {
      validate: () => {
        throw new Error();
      },
      select: () => {
        return 0;
      }
    };
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    const subsTopic = keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    await dsPubsubB.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    await pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await waitFor(() => receivedMessage === true);
    try {
      await dsPubsubB.get(key);
      expect.fail('Should have disguarded invalid message');
    } catch (err) {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    }
  });
  it('should get the second record if the selector selects it as the newest one', async () => {
    const customValidator = {
      validate: () => {
        return Promise.resolve();
      },
      select: () => {
        return 1;
      }
    };
    const newValue = 'new value';
    const record = new Record(key, uint8ArrayFromString(newValue));
    const newSerializedRecord = record.serialize();
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    const subsTopic = keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    await dsPubsubB.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    await pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await waitFor(() => receivedMessage === true);
    await dsPubsubA.put(key, newSerializedRecord);
    await waitFor(() => receivedMessage === true);
    const result = await dsPubsubB.get(key);
    const receivedRecord = Record.deserialize(result);
    expect(receivedRecord.value.toString()).to.not.equal(newValue);
  });
  it('should get the new record if the selector selects it as the newest one', async () => {
    const customValidator = {
      validate: () => {
        return Promise.resolve();
      },
      select: () => {
        return 0;
      }
    };
    const newValue = 'new value';
    const record = new Record(key, uint8ArrayFromString(newValue));
    const newSerializedRecord = record.serialize();
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, customValidator);
    const subsTopic = keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    await dsPubsubB.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    await pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await waitFor(() => receivedMessage === true);
    receivedMessage = false;
    await dsPubsubA.put(key, newSerializedRecord);
    await waitFor(() => receivedMessage === true);
    const result = await dsPubsubB.get(key);
    const receivedRecord = Record.deserialize(result);
    expect(receivedRecord.value.toString()).to.equal(newValue);
  });
  it('should subscribe the topic and after a message being received, discard it using the subscriptionKeyFn', async () => {
    const subscriptionKeyFn = key => {
      expect(uint8ArrayToString(key)).to.equal(`/${ keyRef }`);
      throw new Error('DISCARD MESSAGE');
    };
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, smoothValidator, subscriptionKeyFn);
    const subsTopic = keyToTopic(`/${ keyRef }`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    const res = await pubsubB.getTopics();
    expect(res).to.not.include(subsTopic);
    await dsPubsubB.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    await pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await waitFor(() => receivedMessage === true);
    try {
      await dsPubsubB.get(key);
      expect.fail('Should not have stored message');
    } catch (err) {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    }
  });
  it('should subscribe the topic and after a message being received, change its key using subscriptionKeyFn', async () => {
    const subscriptionKeyFn = key => {
      expect(uint8ArrayToString(key)).to.equal(`/${ keyRef }`);
      return Promise.resolve(topicToKey(`${ keyToTopic(key) }new`));
    };
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const dsPubsubB = new PubsubDatastore(pubsubB, datastoreB, peerIdB, smoothValidator, subscriptionKeyFn);
    const subsTopic = keyToTopic(`/${ keyRef }`);
    const keyNew = topicToKey(`${ keyToTopic(key) }new`);
    let receivedMessage = false;
    function messageHandler() {
      receivedMessage = true;
    }
    const res = await pubsubB.getTopics();
    expect(res).to.not.include(subsTopic);
    await dsPubsubB.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await waitForPeerToSubscribe(subsTopic, peerIdB, pubsubA);
    pubsubB.on(subsTopic, messageHandler);
    await pubsubB.subscribe(subsTopic);
    await dsPubsubA.put(key, serializedRecord);
    await waitFor(() => receivedMessage === true);
    const result = await dsPubsubB.get(keyNew);
    const receivedRecord = Record.deserialize(result);
    expect(uint8ArrayToString(receivedRecord.value)).to.equal(value);
  });
  it('should subscribe a topic only once', async () => {
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    sinon.spy(pubsubA, 'subscribe');
    await dsPubsubA.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    await dsPubsubA.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_NOT_FOUND');
    });
    expect(pubsubA.subscribe.calledOnce).to.equal(true);
  });
  it('should handle a unexpected error properly when getting from the datastore', async () => {
    const dsPubsubA = new PubsubDatastore(pubsubA, datastoreA, peerIdA, smoothValidator);
    const stub = sinon.stub(dsPubsubA._datastore, 'get').throws(errcode(new Error('Wut'), 'RANDOM_ERR'));
    await dsPubsubA.get(key).then(() => expect.fail('Should have failed to fetch key'), err => {
      expect(err.code).to.equal('ERR_UNEXPECTED_ERROR_GETTING_RECORD');
    }).finally(() => {
      stub.restore();
    });
  });
});