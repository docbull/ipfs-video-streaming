'use strict';

var chai_js = require('aegir/utils/chai.js');
var path = require('path');
var util = require('util');
var mkdirp = require('mkdirp');
var rmrf = require('rimraf');
var fs = require('fs');
var interfaceDatastore = require('interface-datastore');
var datastoreCore = require('datastore-core');
var env_js = require('ipfs-utils/src/env.js');
var interfaceDatastoreTests = require('interface-datastore-tests');
var index = require('../src/index.js');
var tempdir = require('ipfs-utils/src/temp-dir.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var mkdirp__default = /*#__PURE__*/_interopDefaultLegacy(mkdirp);
var rmrf__default = /*#__PURE__*/_interopDefaultLegacy(rmrf);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var tempdir__default = /*#__PURE__*/_interopDefaultLegacy(tempdir);

const rimraf = util.promisify(rmrf__default["default"]);
const utf8Encoder = new TextEncoder();
describe('FsDatastore', () => {
  if (!(env_js.isNode || env_js.isElectronMain)) {
    it('only supports node.js and electron main', () => {
    });
    return;
  }
  describe('construction', () => {
    it('defaults - folder missing', () => {
      const dir = tempdir__default["default"]();
      chai_js.expect(() => new index.FsDatastore(dir)).to.not.throw();
    });
    it('defaults - folder exists', () => {
      const dir = tempdir__default["default"]();
      mkdirp__default["default"].sync(dir);
      chai_js.expect(() => new index.FsDatastore(dir)).to.not.throw();
    });
  });
  describe('open', () => {
    it('createIfMissing: false - folder missing', () => {
      const dir = tempdir__default["default"]();
      const store = new index.FsDatastore(dir, { createIfMissing: false });
      chai_js.expect(() => store.open()).to.throw();
    });
    it('errorIfExists: true - folder exists', () => {
      const dir = tempdir__default["default"]();
      mkdirp__default["default"].sync(dir);
      const store = new index.FsDatastore(dir, { errorIfExists: true });
      chai_js.expect(() => store.open()).to.throw();
    });
  });
  it('_encode and _decode', () => {
    const dir = tempdir__default["default"]();
    const fs = new index.FsDatastore(dir);
    chai_js.expect(fs._encode(new interfaceDatastore.Key('hello/world'))).to.eql({
      dir: path__default["default"].join(dir, 'hello'),
      file: path__default["default"].join(dir, 'hello', 'world.data')
    });
    chai_js.expect(fs._decode(fs._encode(new interfaceDatastore.Key('hello/world/test:other')).file)).to.eql(new interfaceDatastore.Key('hello/world/test:other'));
  });
  it('deleting files', async () => {
    const dir = tempdir__default["default"]();
    const fs = new index.FsDatastore(dir);
    const key = new interfaceDatastore.Key('1234');
    await fs.put(key, Uint8Array.from([
      0,
      1,
      2,
      3
    ]));
    await fs.delete(key);
    try {
      await fs.get(key);
      throw new Error('Should have errored');
    } catch (err) {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    }
  });
  it('deleting non-existent files', async () => {
    const dir = tempdir__default["default"]();
    const fs = new index.FsDatastore(dir);
    const key = new interfaceDatastore.Key('5678');
    await fs.delete(key);
    try {
      await fs.get(key);
      throw new Error('Should have errored');
    } catch (err) {
      chai_js.expect(err.code).to.equal('ERR_NOT_FOUND');
    }
  });
  it('sharding files', async () => {
    const dir = tempdir__default["default"]();
    const fstore = new index.FsDatastore(dir);
    await datastoreCore.ShardingDatastore.create(fstore, new datastoreCore.shard.NextToLast(2));
    const file = await fs__default["default"].promises.readFile(path__default["default"].join(dir, datastoreCore.shard.SHARDING_FN));
    chai_js.expect(file.toString()).to.be.eql('/repo/flatfs/shard/v1/next-to-last/2\n');
    const readme = await fs__default["default"].promises.readFile(path__default["default"].join(dir, datastoreCore.shard.README_FN));
    chai_js.expect(readme.toString()).to.be.eql(datastoreCore.shard.readme);
    await rimraf(dir);
  });
  it('query', async () => {
    const fs = new index.FsDatastore(path__default["default"].join(process.cwd(), '/test/test-repo/blocks'));
    const res = [];
    for await (const q of fs.query({})) {
      res.push(q);
    }
    chai_js.expect(res).to.have.length(23);
  });
  it('interop with go', async () => {
    const repodir = path__default["default"].join(process.cwd(), '/test/test-repo/blocks');
    const fstore = new index.FsDatastore(repodir);
    const key = new interfaceDatastore.Key('CIQGFTQ7FSI2COUXWWLOQ45VUM2GUZCGAXLWCTOKKPGTUWPXHBNIVOY');
    const expected = fs__default["default"].readFileSync(path__default["default"].join(repodir, 'VO', key.toString() + '.data'));
    const flatfs = await datastoreCore.ShardingDatastore.open(fstore);
    const res = await flatfs.get(key);
    const queryResult = flatfs.query({});
    const results = [];
    for await (const result of queryResult)
      results.push(result);
    chai_js.expect(results).to.have.length(23);
    chai_js.expect(res).to.be.eql(expected);
  });
  describe('interface-datastore', () => {
    const dir = tempdir__default["default"]();
    interfaceDatastoreTests.interfaceDatastoreTests({
      setup: () => {
        return new index.FsDatastore(dir);
      },
      teardown: () => {
        return rimraf(dir);
      }
    });
  });
  describe('interface-datastore (sharding(fs))', () => {
    const dir = tempdir__default["default"]();
    interfaceDatastoreTests.interfaceDatastoreTests({
      setup: () => {
        return new datastoreCore.ShardingDatastore(new index.FsDatastore(dir), new datastoreCore.shard.NextToLast(2));
      },
      teardown: () => {
        return rimraf(dir);
      }
    });
  });
  it('can survive concurrent writes', async () => {
    const dir = tempdir__default["default"]();
    const fstore = new index.FsDatastore(dir);
    const key = new interfaceDatastore.Key('CIQGFTQ7FSI2COUXWWLOQ45VUM2GUZCGAXLWCTOKKPGTUWPXHBNIVOY');
    const value = utf8Encoder.encode('Hello world');
    await Promise.all(new Array(100).fill(0).map(() => fstore.put(key, value)));
    const res = await fstore.get(key);
    chai_js.expect(res).to.deep.equal(value);
  });
  it('can survive putRaw and getRaw with an empty extension', async () => {
    const dir = tempdir__default["default"]();
    const fstore = new index.FsDatastore(dir, { extension: '' });
    const key = new interfaceDatastore.Key('CIQGFTQ7FSI2COUXWWLOQ45VUM2GUZCGAXLWCTOKKPGTUWPXHBNIVOY');
    const value = utf8Encoder.encode('Hello world');
    await fstore.putRaw(key, value);
    const res = await fstore.getRaw(key);
    chai_js.expect(res).to.deep.equal(value);
  });
});
