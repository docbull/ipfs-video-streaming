'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var PeerId = require('peer-id');
var DuplexPair = require('it-pair/duplex.js');
var pWaitFor = require('p-wait-for');
var Gossipsub = require('@achingbrain/libp2p-gossipsub');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var DuplexPair__default = /*#__PURE__*/_interopDefaultLegacy(DuplexPair);
var pWaitFor__default = /*#__PURE__*/_interopDefaultLegacy(pWaitFor);
var Gossipsub__default = /*#__PURE__*/_interopDefaultLegacy(Gossipsub);

const {multicodec} = Gossipsub__default["default"];
const createMockRegistrar = registrarRecord => {
  return {
    handle: async (multicodecs, handler) => {
      const rec = registrarRecord[multicodecs[0]] || {};
      registrarRecord[multicodecs[0]] = {
        ...rec,
        handler
      };
    },
    register: async ({multicodecs, _onConnect, _onDisconnect}) => {
      const rec = registrarRecord[multicodecs[0]] || {};
      registrarRecord[multicodecs[0]] = {
        ...rec,
        onConnect: _onConnect,
        onDisconnect: _onDisconnect
      };
      return multicodecs[0];
    },
    unregister: () => true
  };
};
const createPubsubNode = async registrarRecord => {
  const peerId = await PeerId__default["default"].create({ bits: 1024 });
  const libp2p = {
    peerId,
    registrar: createMockRegistrar(registrarRecord),
    connectionManager: { getAll: () => [] }
  };
  const pubsub = new Gossipsub__default["default"](libp2p);
  await pubsub.start();
  return pubsub;
};
const ConnectionPair = () => {
  const [d0, d1] = DuplexPair__default["default"]();
  return [
    {
      stream: d0,
      newStream: () => Promise.resolve({ stream: d0 })
    },
    {
      stream: d1,
      newStream: () => Promise.resolve({ stream: d1 })
    }
  ];
};
const connectPubsubNodes = async (pubsubA, pubsubB) => {
  const onConnectA = pubsubA.registrar[multicodec].onConnect;
  const onConnectB = pubsubB.registrar[multicodec].onConnect;
  const handleA = pubsubA.registrar[multicodec].handler;
  const handleB = pubsubB.registrar[multicodec].handler;
  const [c0, c1] = ConnectionPair();
  await onConnectA(pubsubB.router.peerId, c0);
  await onConnectB(pubsubA.router.peerId, c1);
  await handleB({
    protocol: multicodec,
    stream: c1.stream,
    connection: { remotePeer: pubsubA.router.peerId }
  });
  await handleA({
    protocol: multicodec,
    stream: c0.stream,
    connection: { remotePeer: pubsubB.router.peerId }
  });
};
const waitFor = predicate => pWaitFor__default["default"](predicate, {
  interval: 1000,
  timeout: 10000
});
const waitForPeerToSubscribe = (topic, peer, node) => {
  return pWaitFor__default["default"](async () => {
    const peers = await node.getSubscribers(topic);
    if (peers.includes(peer.toB58String())) {
      return true;
    }
    return false;
  }, {
    interval: 1000,
    timeout: 5000
  });
};

exports.connectPubsubNodes = connectPubsubNodes;
exports.createPubsubNode = createPubsubNode;
exports.waitFor = waitFor;
exports.waitForPeerToSubscribe = waitForPeerToSubscribe;
