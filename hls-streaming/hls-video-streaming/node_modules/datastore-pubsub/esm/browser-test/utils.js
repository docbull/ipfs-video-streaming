import PeerId from 'peer-id';
import DuplexPair from 'it-pair/duplex.js';
import pWaitFor from 'p-wait-for';
import Gossipsub from '@achingbrain/libp2p-gossipsub';
const {multicodec} = Gossipsub;
const createMockRegistrar = registrarRecord => {
  return {
    handle: async (multicodecs, handler) => {
      const rec = registrarRecord[multicodecs[0]] || {};
      registrarRecord[multicodecs[0]] = {
        ...rec,
        handler
      };
    },
    register: async ({multicodecs, _onConnect, _onDisconnect}) => {
      const rec = registrarRecord[multicodecs[0]] || {};
      registrarRecord[multicodecs[0]] = {
        ...rec,
        onConnect: _onConnect,
        onDisconnect: _onDisconnect
      };
      return multicodecs[0];
    },
    unregister: () => true
  };
};
export const createPubsubNode = async registrarRecord => {
  const peerId = await PeerId.create({ bits: 1024 });
  const libp2p = {
    peerId,
    registrar: createMockRegistrar(registrarRecord),
    connectionManager: { getAll: () => [] }
  };
  const pubsub = new Gossipsub(libp2p);
  await pubsub.start();
  return pubsub;
};
const ConnectionPair = () => {
  const [d0, d1] = DuplexPair();
  return [
    {
      stream: d0,
      newStream: () => Promise.resolve({ stream: d0 })
    },
    {
      stream: d1,
      newStream: () => Promise.resolve({ stream: d1 })
    }
  ];
};
export const connectPubsubNodes = async (pubsubA, pubsubB) => {
  const onConnectA = pubsubA.registrar[multicodec].onConnect;
  const onConnectB = pubsubB.registrar[multicodec].onConnect;
  const handleA = pubsubA.registrar[multicodec].handler;
  const handleB = pubsubB.registrar[multicodec].handler;
  const [c0, c1] = ConnectionPair();
  await onConnectA(pubsubB.router.peerId, c0);
  await onConnectB(pubsubA.router.peerId, c1);
  await handleB({
    protocol: multicodec,
    stream: c1.stream,
    connection: { remotePeer: pubsubA.router.peerId }
  });
  await handleA({
    protocol: multicodec,
    stream: c0.stream,
    connection: { remotePeer: pubsubB.router.peerId }
  });
};
export const waitFor = predicate => pWaitFor(predicate, {
  interval: 1000,
  timeout: 10000
});
export const waitForPeerToSubscribe = (topic, peer, node) => {
  return pWaitFor(async () => {
    const peers = await node.getSubscribers(topic);
    if (peers.includes(peer.toB58String())) {
      return true;
    }
    return false;
  }, {
    interval: 1000,
    timeout: 5000
  });
};