'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var filter = require('it-filter');
var take = require('it-take');
var merge = require('it-merge');
var base = require('./base.js');
var errors = require('./errors.js');
var utils = require('./utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);
var take__default = /*#__PURE__*/_interopDefaultLegacy(take);
var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);

class MountDatastore extends base.BaseDatastore {
  constructor(mounts) {
    super();
    this.mounts = mounts.slice();
  }
  async open() {
    await Promise.all(this.mounts.map(m => m.datastore.open()));
  }
  _lookup(key) {
    for (const mount of this.mounts) {
      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {
        return {
          datastore: mount.datastore,
          mountpoint: mount.prefix
        };
      }
    }
  }
  put(key, value, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw errors.dbWriteFailedError(new Error('No datastore mounted for this key'));
    }
    return match.datastore.put(key, value, options);
  }
  get(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw errors.notFoundError(new Error('No datastore mounted for this key'));
    }
    return match.datastore.get(key, options);
  }
  has(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      return Promise.resolve(false);
    }
    return match.datastore.has(key, options);
  }
  delete(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));
    }
    return match.datastore.delete(key, options);
  }
  async close() {
    await Promise.all(this.mounts.map(m => {
      return m.datastore.close();
    }));
  }
  batch() {
    const batchMounts = {};
    const lookup = key => {
      const match = this._lookup(key);
      if (match == null) {
        throw new Error('No datastore mounted for this key');
      }
      const m = match.mountpoint.toString();
      if (batchMounts[m] == null) {
        batchMounts[m] = match.datastore.batch();
      }
      return { batch: batchMounts[m] };
    };
    return {
      put: (key, value) => {
        const match = lookup(key);
        match.batch.put(key, value);
      },
      delete: key => {
        const match = lookup(key);
        match.batch.delete(key);
      },
      commit: async options => {
        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));
      }
    };
  }
  query(q, options) {
    const qs = this.mounts.map(m => {
      return m.datastore.query({
        prefix: q.prefix,
        filters: q.filters
      }, options);
    });
    let it = merge__default["default"](...qs);
    if (q.filters)
      q.filters.forEach(f => {
        it = filter__default["default"](it, f);
      });
    if (q.orders)
      q.orders.forEach(o => {
        it = utils.sortAll(it, o);
      });
    if (q.offset != null) {
      let i = 0;
      it = filter__default["default"](it, () => i++ >= q.offset);
    }
    if (q.limit != null)
      it = take__default["default"](it, q.limit);
    return it;
  }
  queryKeys(q, options) {
    const qs = this.mounts.map(m => {
      return m.datastore.queryKeys({
        prefix: q.prefix,
        filters: q.filters
      }, options);
    });
    let it = merge__default["default"](...qs);
    if (q.filters)
      q.filters.forEach(f => {
        it = filter__default["default"](it, f);
      });
    if (q.orders)
      q.orders.forEach(o => {
        it = utils.sortAll(it, o);
      });
    if (q.offset != null) {
      let i = 0;
      it = filter__default["default"](it, () => i++ >= q.offset);
    }
    if (q.limit != null)
      it = take__default["default"](it, q.limit);
    return it;
  }
}

exports.MountDatastore = MountDatastore;
