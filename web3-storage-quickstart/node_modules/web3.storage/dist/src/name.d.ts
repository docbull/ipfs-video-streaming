/**
 * Create a new name with associated signing key that can be used to create and
 * publish IPNS record revisions.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 */
export function create(): Promise<WritableName>;
/**
 * Parses string name to readable name.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {string} name The name to parse.
 */
export function parse(name: string): Name;
/**
 * Create a name from an existing signing key (private key).
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {Uint8Array} key Binary representation of the signing key for the name.
 */
export function from(key: Uint8Array): Promise<WritableName>;
/**
 * Create an initial version of the IPNS record for the passed name, set to the
 * passed value.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {Name} name
 * @param {string} value
 */
export function v0(name: Name, value: string): Promise<Revision>;
/**
 * Create a revision of the passed IPNS record by incrementing the sequence
 * number and changing the value.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {Revision} revision
 * @param {string} value
 */
export function increment(revision: Revision, value: string): Promise<Revision>;
/**
 * Publish a name revision to Web3.Storage.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * ⚠️ Name records are not _yet_ published to or updated from the IPFS network.
 * Working with name records simply updates the Web3.Storage cache of data.
 *
 * @param {import('./lib/interface.js').Service} service
 * @param {Revision} revision Revision of record to publish.
 * @param {SigningKey} key Private key to sign the record with.
 */
export function publish(service: import('./lib/interface.js').Service, revision: Revision, key: SigningKey): Promise<void>;
/**
 * Resolve the current IPNS record revision for the passed name.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {import('./lib/interface.js').PublicService} service
 * @param {Name} name The name to resolve.
 */
export function resolve(service: import('./lib/interface.js').PublicService, name: Name): Promise<Revision>;
/**
 * @typedef {{
 *   bytes: Uint8Array,
 *   verify (data: Uint8Array, signature: Uint8Array): Promise<boolean>
 * }} PublicKey
 *
 * @typedef {{
 *   sign (data: Uint8Array): Promise<Uint8Array>
 * }} SigningKey
 *
 * @typedef {{
 *   public: PublicKey,
 *   bytes: Uint8Array
 * } & SigningKey} PrivateKey
 */
/**
 * Name is an IPNS key ID.
 */
export class Name {
    /**
     * @param {PublicKey} pubKey Public key.
     */
    constructor(pubKey: PublicKey);
    /**
     * @private
     */
    private _pubKey;
    get bytes(): Uint8Array;
    toString(): string;
}
/**
 * WritableName is a Name that has a signing key associated with it such that
 * new IPNS record revisions can be created and signed for it.
 */
export class WritableName extends Name {
    /**
     * @param {PrivateKey} privKey
     */
    constructor(privKey: PrivateKey);
    /**
     * @private
     */
    private _privKey;
    get key(): PrivateKey;
}
/**
 * A represetation of a IPNS record that may be initial or revised.
 */
export class Revision {
    /**
     * Note: if `revision.name` is a `WritableName` then signing key data will be
     * lost. i.e. the private key is not encoded.
     *
     * @param {Revision} revision Revision to encode.
     */
    static encode(revision: Revision): Uint8Array;
    /**
     * @param {Uint8Array} bytes
     */
    static decode(bytes: Uint8Array): Revision;
    /**
     * @param {Name} name
     * @param {string} value
     * @param {bigint} sequence
     * @param {string} validity
     */
    constructor(name: Name, value: string, sequence: bigint, validity: string);
    _name: Name;
    _value: string;
    _sequence: bigint;
    _validity: string;
    get name(): Name;
    get value(): string;
    get sequence(): bigint;
    /**
     * RFC3339 date string.
     */
    get validity(): string;
}
export type PublicKey = {
    bytes: Uint8Array;
    verify(data: Uint8Array, signature: Uint8Array): Promise<boolean>;
};
export type SigningKey = {
    sign(data: Uint8Array): Promise<Uint8Array>;
};
export type PrivateKey = {
    public: PublicKey;
    bytes: Uint8Array;
} & SigningKey;
//# sourceMappingURL=name.d.ts.map