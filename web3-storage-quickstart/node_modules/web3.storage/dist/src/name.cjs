'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fromString = require('uint8arrays/from-string');
var toString = require('uint8arrays/to-string');
var ipns = require('ipns');
var Digest = require('multiformats/hashes/digest');
var identity = require('multiformats/hashes/identity');
var base36 = require('multiformats/bases/base36');
var cid = require('multiformats/cid');
var libp2pCrypto = require('libp2p-crypto');
var cbor = require('cborg');
var fetch = require('@web-std/fetch');
require('@web-std/blob');
require('@web-std/file');
require('ipfs-car/blockstore/fs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);
var Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);
var cbor__namespace = /*#__PURE__*/_interopNamespace(cbor);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);

/**
 * A client library for the w3name - IPNS over HTTP API. It provides a
 * convenient interface for creating names, making revisions to name records,
 * and publishing and resolving them via the HTTP API.
 *
 * @example
 * ```js
 * import { Web3Storage } from 'web3.storage'
 * import * as Name from 'web3.storage/name'
 *
 * const client = new Web3Storage({ token: API_TOKEN })
 * const name = await Name.create()
 *
 * console.log('Name:', name.toString())
 * // e.g. k51qzi5uqu5di9agapykyjh3tqrf7i14a7fjq46oo0f6dxiimj62knq13059lt
 *
 * // The value to publish
 * const value = '/ipfs/bafkreiem4twkqzsq2aj4shbycd4yvoj2cx72vezicletlhi7dijjciqpui'
 * const revision = await Name.v0(name, value)
 *
 * // Publish the revision
 * await Name.publish(client, revision, name.key)
 *
 * // Resolve the latest value
 * await Name.resolve(name)
 * ```
 * @module
 */

const libp2pKeyCode = 0x72;
const ONE_YEAR = 1000 * 60 * 60 * 24 * 365;

const defaultValidity = () => new Date(Date.now() + ONE_YEAR).toISOString();

/**
 * @typedef {{
 *   bytes: Uint8Array,
 *   verify (data: Uint8Array, signature: Uint8Array): Promise<boolean>
 * }} PublicKey
 *
 * @typedef {{
 *   sign (data: Uint8Array): Promise<Uint8Array>
 * }} SigningKey
 *
 * @typedef {{
 *   public: PublicKey,
 *   bytes: Uint8Array
 * } & SigningKey} PrivateKey
 */

/**
 * Name is an IPNS key ID.
 */
class Name {
  /**
   * @param {PublicKey} pubKey Public key.
   */
  constructor (pubKey) {
    /**
     * @private
     */
    this._pubKey = pubKey;
  }

  get bytes () {
    const digest = Digest__namespace.create(identity.identity.code, this._pubKey.bytes);
    return cid.CID.createV1(libp2pKeyCode, digest).bytes
  }

  toString () {
    const digest = Digest__namespace.create(identity.identity.code, this._pubKey.bytes);
    return cid.CID.createV1(libp2pKeyCode, digest).toString(base36.base36)
  }
}

/**
 * WritableName is a Name that has a signing key associated with it such that
 * new IPNS record revisions can be created and signed for it.
 */
class WritableName extends Name {
  /**
   * @param {PrivateKey} privKey
   */
  constructor (privKey) {
    super(privKey.public);
    /**
     * @private
     */
    this._privKey = privKey;
  }

  get key () {
    return this._privKey
  }
}

/**
 * Create a new name with associated signing key that can be used to create and
 * publish IPNS record revisions.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 */
async function create () {
  const privKey = await libp2pCrypto.keys.generateKeyPair('Ed25519', 2048);
  return new WritableName(privKey)
}

/**
 * Parses string name to readable name.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {string} name The name to parse.
 */
function parse (name) {
  const keyCid = cid.CID.parse(name, base36.base36);
  if (keyCid.code !== libp2pKeyCode) {
    throw new Error(`invalid key, expected ${libp2pKeyCode} codec code but got ${keyCid.code}`)
  }
  const pubKey = libp2pCrypto.keys.unmarshalPublicKey(Digest__namespace.decode(keyCid.multihash.bytes).bytes);
  return new Name(pubKey)
}

/**
 * Create a name from an existing signing key (private key).
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {Uint8Array} key Binary representation of the signing key for the name.
 */
async function from (key) {
  const privKey = await libp2pCrypto.keys.unmarshalPrivateKey(key);
  return new WritableName(privKey)
}

/**
 * Create an initial version of the IPNS record for the passed name, set to the
 * passed value.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {Name} name
 * @param {string} value
 */
async function v0 (name, value) {
  return new Revision(name, value, 0n, defaultValidity())
}

/**
 * Create a revision of the passed IPNS record by incrementing the sequence
 * number and changing the value.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {Revision} revision
 * @param {string} value
 */
async function increment (revision, value) {
  const seqno = revision.sequence + 1n;
  return new Revision(revision.name, value, seqno, defaultValidity())
}

/**
 * A represetation of a IPNS record that may be initial or revised.
 */
class Revision {
  /**
   * @param {Name} name
   * @param {string} value
   * @param {bigint} sequence
   * @param {string} validity
   */
  constructor (name, value, sequence, validity) {
    this._name = name;
    if (typeof value !== 'string') {
      throw new Error('invalid value')
    }
    this._value = value;
    if (typeof sequence !== 'bigint') {
      throw new Error('invalid sequence number')
    }
    this._sequence = sequence;
    if (typeof validity !== 'string') {
      throw new Error('invalid validity')
    }
    // TODO: validate format
    this._validity = validity;
  }

  get name () {
    return this._name
  }

  get value () {
    return this._value
  }

  get sequence () {
    return this._sequence
  }

  /**
   * RFC3339 date string.
   */
  get validity () {
    return this._validity
  }

  /**
   * Note: if `revision.name` is a `WritableName` then signing key data will be
   * lost. i.e. the private key is not encoded.
   *
   * @param {Revision} revision Revision to encode.
   */
  static encode (revision) {
    return cbor__namespace.encode({
      name: revision._name.toString(),
      value: revision._value,
      sequence: revision._sequence,
      validity: revision._validity
    })
  }

  /**
   * @param {Uint8Array} bytes
   */
  static decode (bytes) {
    const raw = cbor__namespace.decode(bytes);
    const name = parse(raw.name);
    return new Revision(name, raw.value, BigInt(raw.sequence), raw.validity)
  }
}

/**
 * Publish a name revision to Web3.Storage.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * ⚠️ Name records are not _yet_ published to or updated from the IPFS network.
 * Working with name records simply updates the Web3.Storage cache of data.
 *
 * @param {import('./lib/interface.js').Service} service
 * @param {Revision} revision Revision of record to publish.
 * @param {SigningKey} key Private key to sign the record with.
 */
async function publish (service, revision, key) {
  const url = new URL(`name/${revision.name}`, service.endpoint);
  const entry = await ipns__namespace.create(
    // @ts-expect-error API expects a libp2p-crypto.PrivateKey but only uses SigningKey.sign().
    key,
    fromString.fromString(revision.value),
    revision.sequence,
    new Date(revision.validity).getTime() - Date.now()
  );
  const res = await maybeHandleError(fetch__default["default"](url.toString(), {
    method: 'POST',
    headers: headers(service.token),
    body: toString.toString(ipns__namespace.marshal(entry), 'base64pad')
  }));
  await res.json();
}

/**
 * Resolve the current IPNS record revision for the passed name.
 *
 * **❗️Experimental** this API may not work, may change, and may be removed.
 *
 * @param {import('./lib/interface.js').PublicService} service
 * @param {Name} name The name to resolve.
 */
async function resolve (service, name) {
  const url = new URL(`name/${name}`, service.endpoint);
  const res = await maybeHandleError(fetch__default["default"](url.toString()));
  const { record } = await res.json();
  const entry = ipns__namespace.unmarshal(fromString.fromString(record, 'base64pad'));
  const keyCid = cid.CID.decode(name.bytes);
  const pubKey = libp2pCrypto.keys.unmarshalPublicKey(Digest__namespace.decode(keyCid.multihash.bytes).bytes);

  await ipns__namespace.validate(pubKey, entry);

  return new Revision(
    name,
    toString.toString(entry.value),
    entry.sequence,
    toString.toString(entry.validity)
  )
}

/**
 * @param {string} token
 * @returns {Record<string, string>}
 */
function headers (token) {
  if (!token) throw new Error('missing token')
  return {
    Authorization: `Bearer ${token}`,
    'X-Client': 'web3.storage'
  }
}

/**
 * @param {Promise<Response>} resPromise
 * @returns {Promise<Response>}
 */
async function maybeHandleError (resPromise) {
  const res = await resPromise;
  if (res.ok) return res
  const err = new Error(`unexpected status: ${res.status}`);
  try {
    Object.assign(err, await res.json());
  } catch {}
  throw err
}

exports.Name = Name;
exports.Revision = Revision;
exports.WritableName = WritableName;
exports.create = create;
exports.from = from;
exports.increment = increment;
exports.parse = parse;
exports.publish = publish;
exports.resolve = resolve;
exports.v0 = v0;
//# sourceMappingURL=name.cjs.map
